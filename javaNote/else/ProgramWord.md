# 1일차 단어
- application:  
    응용 프로그램
  
- rendering:  
    이미지/장면을 화면에 출현/표현하는 것
  
- software, program:  
    프로그램은 명령어들의 모음, 소프트웨어는 프로그램 뿐만 아니라 CD, 설명서 등 패키지 전체를 뜻하지만 일반적으로는 같은 의미로 사용된다. 
  
- DNS(Domain Name System):  
    사람이 읽을 수 있는 도메인 이름을 기계가 읽을 수 있는 IP주소로 변환하는 시스템
  
- IP(Internet Protocol):  
    송신 호스트와 수신 호스트가 패킷 교환 네트워크(Packet Switching Network)에서 정보를 주고받는 데 사용하는 정보 위주의 규약(주소)
  
- react:  
    Front End framework, 사용자 인터페이스를 구축하기 위한 JavaScript 라이브러리, "컴포넌트"라고 불리는 코드 파편을 이용하여 복잡한 UI 구성
    
- DOM:  
    문서 객체 모델, HTML문서를 계층적 구조와 정보로 표현하는 자료구조
  
- url(Uniform Resource Locator):  
    웹에 게시된 리소스를 검색하기 위해 브라우저에서 사용하는 메커니즘, 웹에서 주어진 고유 리소스 주소, 즉 네트워크 상에서 자원이 어디 있는지 알려주기 위한 규약
  
- servlet:  
    서버쪽에서 실행되며 클라이언트의 요청을 동적으로 처리할 수 있게끔 도와주는 자바 클래스
  
- servlet container(Tomcat, Jeus):  
    서블릿 여러개를 관리해주는 컨테이너, 
  
- spring framework  
    자바 객체를 담고 직접 관리하는 컨테이너, 서블릿 컨테이너에 실행결과값을 전달한다.
  
- IoC(Inversion of Control):  
    제어의 역전, 제어의 흐름을 사용자가 컨트롤하지 않고 위임한 특별한 객체에 모든것을 맡기는 구조
  
- spring boot:  
    servlet container와 spring framework를 합친 것
  
- WAS(Web Application Server)  
    웹 애플리케이션과 서버 환경을 만들어 동작시키는 기능을 제공하는 소프트웨어 프레임워크
  
- Apache HTTP server:  
    아파치 재단에서 관리하는 오픈 소스, 크로스 플랫폼 HTTP 웹 서버 소프트웨어
  
- nginX?  
    트래픽이 많은 웹사이트의 서버(WAS)를 도와주는 비동기 이벤트 기반구조의 경량화 웹 서버 프로그램
  
- standalone  
    설치만으로 단독적으로 실행 가능한 프로그램
  
- client/server  
    설치(로컬) 또는 웹브라우저를 통해 client와 server를 통신하여 실행하는 프로그램


# 2일차 단어
- uml(Unified Modeling Language):  
    개발 시스템을 이해하기 쉬운 형태로 표현하여 효율적으로 의사소통할 수 있게 해주는 표준화된 모델링 언어, 개발 시 시스템과 산출물을 명세화 시각화 문서화 할 때 사용한다.

- stereotype:  
    UML에서 사람이 이해하기 쉽도록 이름과 설명을 넣어주는 구분자

- instruction set:  
    명령어 집합, 마이크로프로세서가 인식해서 기능을 이해하고 실행할 수 있는 기계어 명령

- compile:  
    소스코드를 바이너리 코드로 변환하는 과정. 프로그래밍 언어로 작성된 소스코드를 컴퓨터가 이해할 수 있는 기계어 혹은 중간 언어로 변환하는 과정이다.

- source code:  
    프로그래밍 언어로 작성된 코드

- bytecode:  
    기계어와 흡사한 구조로된 중간형태의 명령, p-code라고도 불림(진짜 기계어가 아님)

- bytecode interpreter(engine, player, viewer, virtual machine):  
    특정 형식으로 된 명령이나 데이터 입력받아서 해석해서 실행하는 것 == JVM(Java Virtual Machine)

- JRE(Java Runtime Environment):  
    JVM + 실행관련파일

- JDK(Java Development kit):  
    JRE + Java Compiler + debugger + profiler ..

- Java SE(Standard Edition):  
    개인용 웹 개발

- Java EE(Enterprise Edition):  
    기업용 서버 App 제작에 필요한 도구

- Java ME(Micro Edition):  
    임베디드 App 제작에 필요한 도구

- Command Line Interface <-> Graphic User Interface  

- 환경변수:  
    운영체제가 어떤 프로세스를 실행시킬때 실행시키는데 필요한 파일이 있는 경로를 찾는데 이용되는 변수
```
java.exe - 자바 실행파일
javac.exe - 자바 컴파일러
jdb.exe - 자바 디버거
```

- LTS(Long Term Support):  
    일반적인 경우보다 장기간에 걸쳐 지원하도록 특별히 고안된 소프트웨어의 버전

- Process:  
    실행하는 프로그램

- schduling:  
    프로세스 관리  

- Kernel:  
    os의 핵심기능, ex)CPU/RAM 관리, Process 관리/스케줄링

- shell:  
    Kernal의 기능을 사용할 수 있도록 연결 역할을 함 CLI 
```
window => 명령프롬프트, powershell
linux, unix => ex)sh, bash, tsh, csh, zsh
```

- usr:  
    unix resource 파일 저장하는 폴더

- IDE(Integrate Development Environment):

- REPL:  
    Read -> Evaluation(실행) -> Print -> Loop <br> = JSHELL, 간단히 자바 명령을 실행, 테스트 하는 용도

- Repo. (Repository):  
    소스파일 저장소

- Software Configuration Management(SCM):  
    형상관리시스템, 소스변화관리, 버전관리

# 3일차
- QC(Quality Control), QA(Quality Assurance), QM(Quality Management):  
    품질관리, 품질보증, 품질경영 = QC와 QA의 종합적인 의미.

- cursor:  
    컴퓨팅에서 커서(cursor)는 컴퓨터 모니터 등의 디스플레이 장치 위에서 입력을 기다리거나 위치를 가리키는 물체, 곧 포인터를 지칭한다.

- 플레인 텍스트 파일(Askii File):  
    아스키코드로 글자를 나타내는 파일, 다양한 텍스트 편집기로 편집할 수 있는 파일

- markup:  
    콘텐트를 제어하는 명령, 메타데이터, 태그라고도 함

- binary file(이진파일):  
    0과 1이라는 2진수 데이터로만으로 이루어진 파일, 전용 편집기를 사용해야만 편집할 수 있는 파일 ex).jpg, .mp4, .xlsx

- token(git):  
    변경된 데이터를 commit하고 push하는데 사용되는 토큰, 사용자이름/비번 안쳐도 됨

# 4일차
- shell:  
    사용자가 입력한 명령어를 해석해서 운영체제가 이해할 수 있는 기계어로 변환하여 지시해주는 명령 프롬프트라고 이해

- bash(Bourn-Again shell):  
    ourne 쉘의 기능을 계승하고 추가적인 기능을 추가한 쉘, 리눅스/mac os의 기본 쉘이었다.

- zsh:  
    본 쉘의 확장 버전으로 많은 기능과 플러그인 테마를 지원하는 현재 리눅스/mac os의 기본 쉘

- ant(apache.org):  
    자바 기반의 빌드 도구, 빌드 파일 이름은 build.xml

- Maven:  
    apache ant의 대안, 의존라이브러리 기능을 포함, pom.xml

- Gradle:  
    groovy를 기반으로 한 빌드 자동화 도구, 보다 정밀한 빌드과정 제어 가능

- Glob 패턴  
    와일드카드 문자들을 사용해서 일정한 패턴을 가진 파일 이름들의 지정하기 위한 패턴.

# 5일차
- DSL(Domain-Specific Language):  
    특정 영역에 코드를 작성할 때 사용할 언어

# 6일차
- 클래스 블록:  
    컴파일의 기본단위는 클래스 블록이다. 블록은 파일 안 {}을 의미

- API(Application Programming Interface):
    데이터를 주고받기 위한 도구나 규약을 뜻한다.

- API 문서:  
    API의 사용법과 규격을 제공하는 문서

- 애노테이션:  
    자바에서의 애노테이션은 코드 사이에 주석처럼 쓰이며 특별한 의미, 기능을 수행하도록 하는 기술이다.


# 7일차
- RAM(Random Access Memory):  
    프로그램이 실행되는 동안 필요한 정보를 저장하는 컴퓨터 메모리, 전기신호를 통해 데이터를 저장한다.

- HDD(Hard Disk Drive):  
    컴퓨터 데이터를 저장하는 비휘발성 보조기억장치, 자석방향에 따라 데이터 입출력이 가능하다.

- SSD(Solid State Drive):  
    HDD와 달리 반도체 소자를 활용한 보조기억장치

- Sign-Magnitude(부호-크기 절대값):  
    맨 왼쪽 비트를 부호로 취급하여 음수여부를 결정하고 나머지 비트는 절대값으로 저장하는 방식

- 보수(complement):  
    보충해주는 수

- 부동소수점:  
컴퓨터상에서 실수를 표현할 때 소수점의 위치를 고정하지 않고 그 위치를 나타내는 수를 따로 적음

- 가수부, 지수부:  
부동소수점에서 유효숫자를 나타내는 부분을 가수부, 소수점의 위치를 풀이하는 지수부로 나뉜다.


- 유효자릿수:  
소수점을 제외한 후 계산한 자릿수

- 단정도(single-precision):  
    부동소수점을 32비트로 표현하는 방법, float

- 배정도(double-precision):  
    부동소수점을 64비트로 표현하는 방법 32비트에 대비해 두 배 가량 정밀하게 표현할 수 있다, double


# 8일차
- 리터럴(literal):  
    소스 코드의 고정된 값을 나타내는 표기법, 변수에 넣는 변하지 않는 데이터

- Exponetial 기호:
    e기호를 사용하여 소수점의 위치를 조절할 수 있다. ex) 31.4-E1 = 3.14

- UTF-16 LE(Little-Endian), BE(Big-Endian;UCS2):
    16비트로 표현하는 유니코드의 앞 8비트와 뒤 8비트의 순서를 거꾸로 되어 있는 것이 LE 윈도우에서 사용한다. 이론적으로 처리 속도가 더 빨라진다. BE는 앞뒤 바이트 순서가 원래대로 있는 것. 자바와 맥에서 사용한다. 

- Raster폰트(bitmap):  
    특정한 크기나 형태의 문자 세트로, 각 문자가 비트맵(도트패턴)으로 되어 있는 것.

- Vector폰트(truetype:)  
    벡터 그래픽스 형태로 표현된 글꼴

# 9일차
- Reference:  
인스턴스의 주소를 저장하는 변수를 의미한다. 간접적으로 정보를 담고 주소를 참조하여 실제 값을 저장하므로 참조형 변수라고도 한다.

- 변수 호이스팅:  
Javascript 호이스팅은 인터프리터가 코드를 실행하기 전에 함수, 변수, 클래스 또는 임포트의 선언문을 해당 범위의 맨 위로 이동시키는 과정

- r-value, l-value:  
할당연산자 왼쪽 = l-value  
할당연산자 오른쪽 = r-value

- 문장(statement):  
프로그램 내에서 하나의 동작을 기술하는 것. 블록 안에 모여서 메서드와 클래스를 구성. 변수 선언, 조건문, 반복문 등이 해당

- 표현식(expression):  
값을 리턴하는 statement, 어떠한 값을 내포하고 있으면 expression으로 볼 수 있다. 리터럴, 산술식, 리턴값, 변수가 이에 해당

# 10일차
- rust  
    c의 대체자. 모질라 리서치에서 개발한 다중 패러다임, 범용 프로그래밍 언어.

- static type binding(정적 바인딩;Java)  
    변수 선언 시 타입이 고정된다.

- dynamic type binding(동적 바인딩; Javascript)  
    값을 할당할 때 변수의 타입이 결정된다.  

- explicit type conversion(명시적 형변환):  
    명시적으로 타입을 지정하는 것. 지정한 타입으로 형 변환되는 것.

- implicit type conversion(암시적 형변환):
    더 큰 크기의 타입에 변수를 넣는 경우, 혹은 서로 다른 크기의 타입 간 연산 시 작은 크기의 타입이 큰 크기의 타입으로 자동 형 변환되는 것.

- masking(마스킹):  
    AND(&) 비트 연산자를 사용하여 특정 값을 차단.  

- overlay(오버레이):  
    OR(|) 비트 연산자를 사용하여 특정 값 덮어 씌움.(강화)

# 11일차
- parameter(매개변수): 
    argument 값을 담는 로컬 변수

- argument(인수, 인자)
    메서드를 호출할 때 전달하는 값(실제 메모리에 할당되는 데이터)

- generic:
    - 데이터 형식에 의존하지 않고, 하나의 값이 여러 다른 데이터 타입들을 가질 수 있도록 하는 방식  
    - 클래스 내부에서 지정하는 것이 아닌 외부에서 사용자에 의해 지정되는 것. 타입을 미리 지정하지 않고 컴파일 때 해당 타입으로 캐스팅하여 매개변수화된 유형을 삭제하는 방식

- Raw type
    제네릭 타입에서 Type Parameter를 전혀 사용하지 않을 때 로 타입이라고 한다. 

- enum(열거 타입):  
    요소, 멤버라 불리는 명명된 값의 집합을 이루는 자료형, 변수명만 사용할 것을 목적으로 만들 상수 데이터 집합, 값이 존재하지 않는다.

- label(라벨)
    다중반복문에 이름을 부여하는 방법  
    첫 반복문 앞에 '(이름):'을 붙여 사용

- Scanner:  
    입력과 관련된 클래스, util 패키지 경로에서 호출하여 사용

- overriding:  
    - 상속 관계에 있는 부모 클래스에서 이미 정의된 메소드를 자식 클래스에서 같은 시그니쳐를 갖는 메소드로 다시 정의하는 것.  
    - 부모의 private 멤버를 제외한 모든 메소드를 자식클래스에서 사용할 수 있는데 이때 필요동작을 위해 재정의하는 것

# 12일차
- pipeline(|):  
    리눅스에서 pipeline은 명령어 1의 처리결과를 명령어2에 전달하는 것을 의미한다.

- wc 명령어:  
    WordCount 의 약자로, 파일에 들어있는 단어 및 라인의 개수와 파일 크기를 표시해준다.

- cat 명령:  
    파일(들)의 내용을 출력하는 명령어, 여러 파일을 이어서 출력할 수도 있다.
- 스트림(stream):
    프로그램을 드나드는 데이터, 파일 등의 바이트 흐름, 자바에서는 입력/출력스트림으로 구분되어 데이터의 입구/출구의 개념으로 이해하면 된다.

- token:  
    문법적으로 더 이상 나눌 수 없는 언어의 요소, 구문적으로 의미를 갖는 최소의 단위, 즉 기본 '단어'

- 객체:  
    변수에 레퍼런스 정보가 들어있는 것은 아니지만 정보가 들어 있는 변수로 간주하여 객체라고 표현한다.  
    또 클래스를 통해 정의된 변수인 인스턴스를 객체라고도 부른다.

- 메소드:  
    레퍼런스에 적혀있는 주소를 통해 인스턴스를 찾아서 작업을 수행하도록 하는 명령어

- 인스턴스(instance):
    데이터가 메모리에 할당되어 실제 저장된 것

- 클래스 변수(static field):
    메서드 밖에 클래스에 선언된 변수, 앞에 static을 붙여 선언, 클래스 내부의 모든 메서드에서 변수 사용이 가능하다.

- 로컬 변수:
    메서드 내에 선언된 변수, 선언된 메서드 블록 내에서만 사용가능하고 블록 실행 종료 시 제거된다. 

# 13일차
- replace temp with query:  
    임시 변수를 질의 함수 형태로 변환하는 리팩토링 기법

- 메서드(=함수):  
    코드를 관리하기 쉽고 재사용하기 쉽도록 기능 단위로 묶어놓는 문법

- 메서드 시그니쳐:  
    메서드 이름과 파라미터 리스트의 조합

- 메서드 바디:  
    메서드가 실행될 떄 수행되는 코드 블록, 실질적인 동작/작업

1 4  13  5  8 10

1





- 가변 파라미터:  
    - [리턴타입] 메서드명(타입... 변수) {...}  
    - 0개 이상의 값을 받을 떄 선언한다.  
    - 메서드 내부에서는 배열처럼 사용한다.

- 배열 파라미터:  
    - [리턴타입] 메서드명(타입[] 변수) {...}  
    - 배열을 직접 담아서 전달, 배열을 넘길 경우 복제가 아닌 그대로 사용
    - 낱개의 값을 전달할 수 없다. 오직 배열주소만 넘겨야 한다.

- call by value: 
    메서드를 호출할 때 값을 넘기는 경우 call by value라고 한다. 이 때 값은 primitive data type, 즉 byte short char int long float double 총 8개만 존재한다.

- call by reference:
    primitive data type을 제외한 나머지는 모두 reference type으로 객체에 인스턴스 주소를 전달하는 경우이다. 인스턴스의 실제 메모리는 heap영역에 저장되며 그 인스턴스가 저장되어 있는 주소를 레퍼런스라고 한다. 

- Stack:  
    호출된 메서드의 로컬 변수를 두는 곳

- Heap:  
    new 명령으로 만든 변수(인스턴스)를 두는 곳

- Method Area:  
    class byte code를 두는 곳
    static(class) 변수 두는 곳

- Thread:  
    프로세스안에서 실질적으로 작업을 실행하는 단위, 하나의 코드실행흐름
    스레드는 각각 Stack 영역은 따로 할당 받고 나머지 영역은 공유한다.따라서 하나의 쓰레드에서 오류가 발생한다면 프로세스의 다른 쓰레드도 모두 강제 종료 된다.

- Frame:  
    - 메서드를 호출하는 시점에 생성된 메모리 영역을 Frame이라고 한다.
    - Stack 영역에 할당, 메서드가 종료되면 파괴된다. 로컬변수를 array형태로 갖는다.

- stack overflow:  
    JVM 스택 메모리가 꽉 차서 더이상 메서드 실행에 필요한 로컬 변수를 만들 수 없는 상태일 때 발생하는 에러, 재귀호출과 같이 Frame과 로컬변수 많이 만드는 상황에서 많이 발생한다.

- 리팩토링(Refactoring):  
    결과의 변경없이 코드의 구조를 재조정함으로써 가독성과 재사용성을 높여 유지보수를 편하게 하는 기법

# 14일차

- 프로그램 아규먼트:  
    JVM을 실행할 때 프로그램에 전달하는 값

- JVM 아규먼트:  
    JVM에 전달하는 값

- System.getProperty():  
    자바 실행 시, 실행되는 곳의 정보를 얻어오거나 운영체제의 정보가 필요할 때 사용하는 메서드. 시스템의 정보를 가져와야 할 때 사용한다. 

- 기술 부채:  
    - 프로젝트나 소프트웨어 개발에서 미루어진 기술적인 결정이나 품질에 대한 저하를 나타내는 개념
    - 초기에 빠른 개발을 위해 단기적으로 특정 기술적 결정을 내리거나, 코드를 간추리거나, 문제를 미루는 등의 선택이 있을 때 발생한다. 

- extract method:  
    메서드 추출. 어떤 코드를 기능에 따라 묶어도 된다는 판단이 들면 해당 코드들을 빼내어 목적을 나타내는 메서드로 만드는 리팩토링 기법

- Context Menu(Popup Menu):  
    마우스로 우클릭했을 떄 나오는 메뉴

- bidirectional/unidirectional Association:  
    양방향 관계/단방향 관계(참조). 클래스가 서로 참조하는 경우 bidirectional association이고 한쪽만 참조하는 경우 unidirectional association이다. 양방향 참조가 발생할 경우 두 클래스는 강력한 연결에 의해 의존성이 강해져서 재사용성이 떨어지기 때문에 이를 리팩토링을 통해 단방향 참조로 재구성하는 것이 좋다. 

- Patterns:  
    특정 문제를 해결하기 위해 실무에 널리 사용하는(검증된) 설계 기법

- GRASP Pattern
    General Responsibility Assignment Software Patterns  
    객체지향 디자인의 클래스 및 객체에 책임을 할당하는 원칙을 말하는 패턴으로 총 9가지의 원칙이 존재한다.

- information expert:  
    GRASP 패턴 원칙 중 하나. 객체에게 책임을 할당할 때 가장 기본이 되는 책임 할당 원칙. 책임을 수행할 정보를 알고있는 객체에게 책임을 할당. 즉 새로운 기능이나 방법을 추가할 때 그에 필요한 정보를 가지는 클래스, 객체를 대상으로 수정해야 한다는 것.


# 15일차
- 클래스 로딩(class loading):  
    - 클래스 로더가 .class 파일을 찾고 읽어서 배치하는 것, 적재라고 표현한다. 
    - 클래스 로딩할 때 static 변수도 생성되어 method area에 배치된다.

- 클래스 메서드 
    - 메서드 앞에static이 붙어있다.
    - 인스턴스 주소를 파라미터로 전달한다.
    - 객체 생성 없이 클래스명.메서드명(파라미터)로 호출 가능

- 인스턴스 메서드
    - 반드시 객체를 생성해야만 호출 가능(new)
    - 파라미터를 사용해서 작업을 수행한 후 그 결과를 내부적으로 보관할 때 사용
    - 객체 생성 후, 메서드명 앞에 인스턴스 주소를 전달하여 호출한다. 레퍼런스.메서드명(파라미터)

- 인스턴스 메서드 this 내장변수:  
인스턴스 주소를 직접 적을 필요 없이 앞에서 전달한 인스턴스 주소를 자동 저장해주는 문법

- 패키지 멤버:  
    - 패키지에 안에 포함된 클래스나 인터페이스
    - 패키지 멤버끼리는 참조에 제약이 없다
    - 외부 패키지에서 접근하려고 할 때는 제약이 있다. 

# 16일차
- 생성자:  
    객체를 초기화하고, 개체가 생성될 때 필요한 작업을 수행하는 특별한 메서드. 클래스의 이름과 동일하며 new 키워드와 함께 호출된다. 객체의 초기상태를 유효한 값으로 설정하도록 강요하는 것이 핵심이다.

# 17일차
- 레퍼런스 배열:  
    객체의 레퍼런스를 저장하는 배열. 

- 인스턴스 배열:  
    자바에서는 존재하지 않는다.

# 18일차
- 의존객체:  
    의존 객체란 객체 지향 프로그래밍에서 한 객체가 다른 객체에 의존하는 경우를 나타낸다. 즉 한 객체가 다른 객체의 기능을 사용하는 경우를 의미한다.

- C&P:  
    컴퓨터에서 텍스트, 그림, 파일 등을 붙여넣는 동작을 가리킨다. 개발의 관점에서는 코드를 재사용하여 유사한 기능을 하는 프로그램을 만들기 위해 사용된다. 즉 복붙하여 필요한 부분만 수정하는 과정
    

# 19일차
- NullPointerException:  
    실제 값이 아닌 null을 가지고 있는 객체/변수를 호출할 때 발생하는 예외(에러)
- nested class(중첩클래스):  
    클래스 내에 정의된 클래스, 정적 중첩 클래스와 내부 클래스로 나누어진다.  

- Class.forName:  
    개발자가 직접 메모리를 로딩시키는 명령문, 패키지 이름을 포함하여 클래스명까지 다 작성해야 한다. 단 마지막 클래스명 앞에는 "."이 아니라 "$"를 붙여야 한다.
    Ex) ("com.eomcs.oop.ex03.Exam0660$A")

- static initializer:  
    스태틱 초기화 블록은 클래스가 로드될 때 실행되는 블록으로, 처음 로드될 때 단 한번만 실행되며 클래스 필드나 클래스 수준의 초기화 작업을 수행한다.


- instance initializer:  
    인스턴스 초기화 블록은 여러 생성자에 공통으로 들어가는 코드를 작성할 때, 그리고 익명클래스라 생성자를 만들 수 없을 때 사용한다. new 명령이 실행될 때마다 실행되며 컴파일 시 생성자로 복사되고 초기화 블록은 제거된다. 

# 20일차
- 인터페이스:  
    객체 사용 규칙을 정의하는 문법

- responsibility:  
    GRASP패턴에서 제시하는 책임은 객체가 수행하는 역할 또는 작업을 의미한다.

- Composite 패턴:  
    GoF에서 소개된 구조 패턴중 하나로 객체들을 트리 구조로 구성하여 복합 객체나 개별 객체를 동일한 방법으로 다룰 수 있도록 하는 패턴

- 개별 객체, 복합 객체, 인터페이스:  
    - 개별 객체(Leaf)는 더 이상 분해되지 않는 원자적인 객체, 즉 더 이상 자식 객체를 가지지 않는 파일과 같은 객체이다.
    - 복합 객체(Composite)는 개별객체 또는 다른 복합 객체를 자식으로 가지는 객체, 파일시스템에서 폴더 디렉토리와 같다. 
    - 공통 인터페이스(Component)는 Leaf와 Composite를 구분하지 않고 동일한 방식으로 다루기 위한 정의이다.

- 클라이언트:  
    다른 객체를 사용하는 객체, 또는 어떤 객체의 서비스를 사용하는 코드. 상대적인 개념이다.

- 노드:  
    트리나 그래프 구조에서 기본 단위로서, 데이터를 저장하며 다른 노드들과의 관계를 표현하는 객체, Composite패턴에서는 자식원소를 가진 원소로 정의하기도 한다.

- 컴포넌트:  
    Composite 디자인 패턴에서 개별객체와 복합객체를 동일하게 처리할 수 있도록 하는 공통 인터페이스로서 사용되는 개념

- 추상 메서드:  
    완성되지 않은 메서드

- 옵저버(observer) 패턴:  
    메뉴를 실행하라는 명령이 들어왔을 때(이벤트가 발생했을 때) 작업을 수행한다. 이때 이를 관찰하고 있던 옵저버에게 소식이 전해진다.


# 21일차
- Business Logic:  
    작업을 수행하는 코드

- interface:  
    OOP에서 사용되는 추상화의 한 형태로 클래스가 특정 메서드나 속성의 집합을 가져야 하는 규칙을 정의한 것. 클래스를 강제한다.

- concrete(구체적인):  
    인터페이스 규칙에 따라 만들어진 실제로 구현하거나 인스턴스화 한 것을 나타내는 개념.

- caller(=client):  
    어떤 함수나 메서드, 객체를 호출하는 역할을 하는 코드(객체)

- callee:  
    어떤 함수나 메서드, 객체를 호출받아 실행되는 코드(객체)

- 캡슐화(Encapsulation):  
    - OOP의 개념 중 하나로, 데이터와 해당 데이터를 처리하는 메서드(또는 함수)를 하나로 묶는 것
    - 객체 내부의 세부 구현을 외부로부터 숨김으로써 내부 구조를 감추는 것을 목적으로 한다. 
    - 내부 구조를 변경하더라도 사용하는 측에는 영향을 주지 않게 하기 위함 => 재사용성 강화 (정보 은닉)

- 상속:  
    OOP의 개념 중 하나, 하위클래스가 상위클래스의 특성(속성과 메서드)을 상속받는 것을 의미한다. 재사용성, 확장성, 일반화, 다형성의 특징을 가진다.

- 다형성, 다형적 변수:  
    - OOP에서 여러 클래스가 공통적인 부모클래스를 가지고 있을 때, 이들을 동일한 타입으로 다루는 특성
    - 다형적 변수는 여러 하위 클래스 객체들을 담을 수 있는 변수, 공통 부모클래스의 타입으로 선언한다.

- 수퍼클래스(부모클래스), 서브클래스(자식클래스):  
    - 수퍼클래스는 상위클래스로서 하위클래스에 속성과 메서드를 상속해준다.
    - 서브클래스는 하위클래스로서 상속받은 속성과 메서드를 포함하며, 필요에 따라 추가적인 속성이나 메서드를 가질 수 있다. 

# 22일차
- DTO(Data Transfer Object):  
    객체 간에 데이터를 전송하는 데 사용되는 디자인 패턴. 이는 주로 데이터베이스와의 상호 작용, 웹 서비스 호출 또는 시스템 간의 통신과 같이 다양한 상황에서 데이터를 전달하기 위해 사용됩니다.

- Java Collection API:  
    자바에서 데이터 그룹을 다루기 위한 표준화된 인터페이스와 구현 클래스들을 제공하는 프레임워크. 라이브러리 API에 해당한다. 특정 목적에 맞는 자료구조 및 알고리즘을 제공하여 개발자가 효율적으로 데이터를 다룰 수 있도록 해준다. 

- .getClass():  
    - Object클래스에서 제공되는 메서드로 객체의 클래스 정보를 반환한다. 즉 어떤 클래스인지 확인하는 용도로 사용된다. 
    - 레퍼런스가 가리키는 인스턴스의 실제 클래스 정보를 반환한다.
    - == 연산자를 사용하여 특정 클래스의 인스턴스인지 좁혀서 알 수 있다.

- 클래스명.class:  
    클래스 정보를 갖고 있는 스태틱 변수이다.
```
System.out.println(v.getClass() == Sedan.class)
```

- ArrayList:  
    java.util 패키지에서 제공하는 클래스, 배열의 크기를 조절하는 자료구조, 메서드들이 포함되어 있다.

- System.arraycopy:  
    - 배열 간의 요소를 복사하는 메서드. 원본배열과 복사할 배열이 필요하다.
    - 파라미터 구성으로 src, srcPos, dest, destPos, length가 있다.
```
1. src: 복사할 원본 배열
2. srcPos: 원본배 열에서 복사를 시작할 인덱스
3. dest: 복사된 데이터를 저장할 대상 배열
4. destPos: 대상 배열에서 데이터를 저장 시작할 인덱스
5. length: 복사할 요소의 수
```
- Arrays.copyOf:  
    - 배열을 복사하여 새로운 배열을 생성하는 메서드, 원본 배열만 있으면 된다.
    - 일반적인 파라미터 구성은 original, newLength
```
1. original: 복사할 원본 배열
2. newLength: 생성될 새로운 배열의 길이
3. type: 세번째 파라미터는 생성될 배열의 타입을 지정한다.(필요시)
```

# 23일차
- Singleton 패턴  
    오직 하나의 객체(인스턴스)만 생성하고, 이에 대해 전체 프로그램에 공유할 수 있도록 하는 설계 기법

- Factory Method 패턴:  
    객체 생성을 서브 클래스에서 처리하도록 하는 기법, 객체 생성과정이 복잡할 때 캡슐화를 통해 단순화하는 것이 목적이다. 

- deprecated:  
    메서드가 사라질 것으로 예상되어 사용하지 말라고 권고할 때 사용

- .getInstance():
    실글턴 패턴에서 사용되는 메서드 이름, 해당 클래스의 유일한 인스턴스를 반환하도록 작성된다. 예를 들어 해당 클래스의 인스턴스가 있으면 인스턴스를 반환하고 없으면 new를 통해 인스턴스를 생성하도록

- .charAt():  
    String클래스에서 제공되는 메서드, 문자열에서 특정 위치의 문자를 가져오는데 사용된다. 파라미터로 인덱스값을 입력한다.

- .compareTo():  
    - 객체들 간에 대소 비교를 수행하는데 사용되는 메서드, 정렬 알고리즘에서 객체들을 비교할때 사용된다.
    - 0은 동등, 음수는 호출된 객체가 매개변수보다 작음, 양수는 호출된 객체가 매개변수보다 큼

- .contains():  
    - 특정 요소가 컬렉션에 포함되어 있는지 여부를 확인하는 메서드
    - 해당 요소가 컬렉션에 존재하면 true, 없으면 false를 반환

- .equals():  
    객체가 같은지 비교하는 메서드

- .concat():  
    문자열을 이어붙이기 위해 사용되는 메서드, 매개변수로 주어진 문자열을 연결하여 새로운 문자열을 반환한다.

- immuatable:
    불변 객체를 표현할 때 사용, 인스턴스가 한번 생성되면 값을 변경할 수 없다. 배열도 마찬가지 길이를 변경할 수 없다.

- .getByte():  
    String 클래스에서 제공되는 메서드, 문자열에서 특정 인덱스 위치에 있는 문자의 바이트 값을 반환한다.

- .getBytes():  
    - 문자열을 바이트 배열로 변환해준다.
    - 바이트배열에 들어있는 문자코드가 어떤 문자집합에 맞춰 작성되었는지 알려주지 않으면 JVM이 가정하는 문자집합으로 생각하고 변환하기 때문에 파라미터로 이를 명시해줘야 한다..
    - 이클립스에서 실행할 경우: UTF-8로 간주한다.

- .defaultCharset():  
    현재 시스템의 기본 문자 집합을 나타내는 Charset 객체를 반환한다. ex) ms949, utf-8

- .join():  
    - 구분자열과 문자열을 파라미터로 받아서 새 문자열을 만든다. 
    - 첫번째 파라미터로 구분자열을 받는다.

- .valueOf():  
    - 다양한 자료형을 해당 클래스 타입으로 변환하는 메서드
    - valueOf()를 통해 객체를 만들면 자주 쓰는 값(1바이트: -128 ~ +127)에 대해서는 한 번만 만들어 공유한다.

- Math.ceil():  
    부동소수점 바로 위 정수값을 리턴한다.

- Math.floor():  
    부동소수점 바로 아래 정수값을 리턴한다.

- .intValue():  
    Integer 객체를 기본 정수 타입으로 변환할 때 사용되는 메서드

- Math.pow():  
    거듭제곱을 계산해준다. 파라미터로 밑과 지수를 받는다.

- Math.round():  
    부동소수점을 받아 반올림하여 정수값을 리턴한다.

- .toString():  
    객체를 문자열로 변환해주는 메서드

- .get():  
    데이터 구조나 컬렉션에서 해당 인덱스 또는 키에 해당하는 요소를 가져오는 용도로 사용된다.
    
- 상속:  
상속은 하위클래스가 상위 클래스의 기능을 받아 사용하는 것. 수퍼클래스로 지정한 코드를 내것처럼 쓰겠다는 의미이다.



# 24일차
- specialization(전문화):  
    - 기존 클래스를 확장하여 클래스를 생성하는 과정
    - 상위클래스의 특성을 상속받아 새로운 기능을 가진 하위클래스를 생성하는 경우이다.

- generalization(일반화):
    - 하위클래스로부터 공통된 특성을 가진 상위클래스를 추출하여 생성되는 과정
    - 여러 클래스 간의 공통된 특성을 상위클래스 메서드로 묶어 재사용성과 유지보수성을 높이는 경우이다.

- instanceof 연산자:  
    - 레퍼런스에 들어있는 특정클래스의 인스턴스인지 검사한다.
    - 상위/하위 클래스의 인스턴스인지도 검사하기 힘들기 때문에 정확히 어느 클래스에 있는지는 알기 힘들다.

- Method Overloading:
    파라미터의 형식(타입과 개수)이 다르더라도 같은 작업을 수행하는 메서드에 대해 같은 이름을 부여함으로써 프로그래밍에 일관성을 제공하는 문법

- Method Overriding:  
    상속받은 메서드를 서브클래스의 역할에 맞게 재정의하는 문법


# 26일차
- 추상클래스:  
    서브클래스에게 공통 필드나 메서드를 상속해주는 것을 목적으로 수퍼클래스를 만들 경우, 일반적으로 해당 클래스에서 인스턴스를 생성하지 않기 때문에 이를 막기 위한 문법이 추상클래스이다.

- 추상메서드:  
    서브클래스에게 메서드 구현을 강제하고 싶을 때 추상메서드를 사용한다. 즉 오버라이딩을 통해 재정의될 메서드이기 때문에 추상메서드를 통해 메서드명을 통일시키고 메서드 구현을 강제한다. 구현 안할 시 그 클래스도 추상클래스여야만 한다.

- concrete 클래스/메서드:  
    추상클래스, 인터페이스의 구현이 가능하여 실제 인스턴스를 생성하는 클래스/메서드를 말한다. 

- Template Method 패턴:  
    실행흐름(알고리즘)은 슈퍼클래스에서 정의하고, 작업을 수행하는 기능은 서브클래스에서 정의하여 캡슐화함으로서 코드 재사용성을 높이고 알고리즘에 대한 관리를 슈퍼클래스에 독점시킨다.

- Encapsulation:  
    인스턴스의 변수에 추상화 목적에 맞는 유효한 값만 넣을 수 있도록 외부 접근을 제한하는 문법이다.

- getter:  
    캡슐화를 하기 위해 외부에서 인스턴스에 직접 접근을 제한한 경우, 해당 클래스의 인스턴스 변수 값을 반환하는 메서드로 변수에 접근하고 값을 가져오는 역할을 수행한다.

- setter:  
    인스턴스 변수 값을 저장하는 메서드, 저장하기에 유효한 값인지 유효성 검사 후 값을 저장해주는 역할을 수행한다.

- Property
    - read-write property: getter만 있을 경우
    - read-only property: setter만 있을 경우
    - write-only property: 둘다 있는 경우

- trade off:  
    - 타협, 거래
    - 대립되는 속성 간 교환요소를 나타내는 개념으로, 하나를 얻기 위해서는 다른 것을 희생해야 되는 상황
    - 예를 들어 성능을 향상시키기 위해 메모리 사용량 증가가 불가피한 경우를 들 수 있다.

- 접근제한자(modifier):  
    - private: 같은 클래스만 공개
    - default: 같은 클래스 또는 같은 패키지에 공개
    - protected: 같은 클래스 또는 같은 패키지 또는 자식 클래스에 공개
    - public: 모두 공개


# 27일차
- Object클래스:  
    자바 모든 클래스의 최상위 클래스, 대표적으로 getClass(), toString(), hashCode()와 같은 메서드들을 가지고 있다.

- toString():  
    "클래스이름@해시코드" 형태의 문자열을 반환하며, 이를 오버라이딩하여 각 클래스의 특정 내용을 문자열로 반환하도록 할 수 있다.

- API:  
    API는 응용 프로그램이 서로 통신하고 상호작용하기 위해 정의된 메서드, 프로토콜, 도구, 클래스 등의 집합. API를 사용하면 개발자들은 다른 응용 프로그램 또는 서비스에서 제공하는 기능을 활용할 수 있다. 즉 다른 개발자가 만들어놓은 코드를 활용할 수 있도록 만든 것이 API이다.

- Library:  
    다른 사람이 만든 코드, 즉 메서드/클래스/모듈 등을 묶어놓은 것을 의미한다.

- Module:  
    파일 단위로 구성된 독립적이고 재사용 가능한 프로그램의 일부, 코드의 특정 기능이나 역할을 담당하는 논리적인 블록을 의미한다.

- Package:  
    관련된 클래스와 인터페이스를 논리적으로 그룹화한 것으로, 서로 관련된 기능을 수행하는 클래스를 패키지 단위로 묶음으로서 코드의 가독성과 유지보수성을 향상시킨다.

- JAR(Java Archive):  
    자바 플랫폼에서 사용되는 압축된 파일 형식으로 여러 자바 클래스 파일, 리소스, 메타데이터를 포함하는 패키지이다. 자바 애플리케이션을 배포하고 실행하는데 활용된다.

- StringBuffer:  
    자바에서 문자열을 변경할 수 있는 가변(mutable)한 클래스이다. 문자열의 추가, 삽입, 삭제 등의 연산을 효율적으로 수행할 수 있다. .equals()를 오버라이딩 하지 않는다.

- wrapper:  
    Wrapper 클래스는 기본 데이터 타입(primitive data type)을 객체로 감싸는 역할을 하는 클래스이다. 기본 데이터 타입을 객체로 다룰 수 있도록 만들어졌다.

- Integer.toHexString():  
    10진수 정수를 16진법 정수로 변환해주는 메서드 wrapper 클래스의 Integer 메서드이다.

# 28일차
- Hash value:  
    데이터를 수학적 연산(hash algorithm;함수)에 따라 변환한 고유의 고정된 크기 값으로 무결성 검증, 데이터 검색/비교, 암호학에 사용된다.

- constant pool:  
    JVM의 메모리 영역 중 하나로 상수들을 저장하는 특별한 메모리 영역이다. 상수값을 중복해서 저장하지 않고 cashe하여 메모리 효율성을 높인다.

- synchronized(동기화 처리):  
    동시에 여러 스레드 진입 불가, 즉 멀티스레드 환경에서 여러 스레드가 공유 데이터 또는 리소스에 안전하게 접근하도록 하는 메커니즘이다.

- Thread-Safe:  
    - 여러 스레드가 동시에 작업하더라도 문제가 발생하지 않도록 조치를 했음을 의미
    - 여러 스레드가 동시에 진입해서 명령을 실행하더라도 문제가 발생하지 않음을 의미

# 29일차
- CSV(Comma-Seperate Values):  
    데이터를 저장하는데 널리 사용되는 텍스트 형식, 각 데이터 필드를 쉼표(,)로 구분되어 있으며, 각 행은 줄바꿈으로 구분된다.

- deprecated:  
    deprecated 상태는 자바에서 특정 메서드, 클래스, 필드 등이 더 이상 사용되지 않을 것이라고 표시하는 데 사용한다. 즉 사용하지 않는 것이 좋다고 결정되었고, 가까운 장래에 삭제될 가능성이 있으니 사용하지 말라고 경고하는 것이다.

- 밀리초:  
    1초의 1/1000등분한 시간 단위

- auto boxing/unboxing:  
    - 오토박싱(auto-boxing)
        - 자동으로 박싱해주는 문법, 리터럴을 저장하면 컴파일 시 컴파일러가 자동으로 메서드를 호출하는 코드로 변환해준다.
    - 오토언박싱(auto-unboxing)
        - 자동으로 언박싱해주는 문법, 객체를 저장하면 컴파일러가 자동으로 value를 호출하는 메서드로 변환해준다.

# 30일차
- 자원해제:  
    파일 연결, 네트워크 연결, 데이터베이스 연결, 입출력 스트림 연결 등 외부 자원을 사용할 때 JVM을 종료하지 않는 이상 계속 사용되기 때문에 메모리 누수가 발생하거나 다른 프로그램으로 연결할 수 없기 때문에 close() 메서드를 통해 연결을 해주어야 하는데 이를 "자원 해제"라고 부른다. 
    
# 31일차
- 중첩클래스:  
    중첩 클래스는 클래스의 사용범위를 제한하는 문법이다. 즉,클래스 내부에 다른 클래스를 정의하는 것으로, 코드 구조를 구성하고 모듈화하여 가독성을 향상시키고 캡슐화를 촉진하여 유지보수를 쉽게 하기 위한 문법이다.

- Collection API:  
자바의 Collection API는 데이터를 쉽게 저장하고 다룰 수 있도록 제공하는 표준 라이브러리이다. 주요 인터페이스로 Collection, List, Set, Queue, Map이 있다. 이를 구현하는 자료구조로는 ArrayList, HashSet, HashMap 등이 있다.

# 32일차
- LIFO:  

- 