# 학습점검목록 5주차
<span style="font-size:120%">

# 20일차 (2023-12-11,월)
### 1. 인터페이스 문법의 용도를 설명할 수 있는가?
  - 인터페이스 문법은 객체 사용 규칙을 강제하는 정의하는 문법이다. 예를 들면 여러 개발자가 특정 메서드 이름을 통일성 있게 설정할 수 있도록 인터페이스에 정의하면 해당 메서드를 작성하지 않았을 때 컴파일 에러를 발생시킨다.

### 2. SOLID OCP(Open/Closed Principle) 원칙에 대해 설명할 수 있는가?
  - OCP는 기능 추가/확장에 대해서는 열려있어야 하고 변경에 대해서는 닫혀있어야 한다는 원칙이다. 즉 새로운 기능을 추가할 때 기존 코드를 수정하지 않아도 되도록 설계해야한다는 원칙을 나타낸다.

### 3. GRASP의 Low Coupling 책임 할당 원칙에 대해 설명할 수 있는가?
  - Low Coupling은 객체,모듈,클래스 사이의 의존성이 낮아야 한다는 원칙이다. 
  - 책임 할당 원칙은 데이터를 가지고 있는 객체에서 데이터를 처리하도록 함으로써 의존성을 낮추어 Low Coupling을 이루고자 하는 원칙이다.

### 4. GoF의 Composite 패턴을 설명할 수 있는가?
  - Composite 패턴은 객체를 트리 구조, 구성하여 복합객체와 개별객체를 동일한 방법으로 다룰 수 있도록 하는 디자인 패턴이다. 쉽게 말해 강결합되어 있는 객체의 연결을 느슨하게 만들고 재사용성을 강화하기 위해 계층적인 구조로 만드는 설계 기법이다.

# 21일차 (2023-12-12,화)
### 1. GRASP 책임 할당 지침 중에서 Information Expert에 대해 설명할 수 있는가?
  - Information Expert란 책임을 수행할 정보를 알고있는 객체에게 책임을 할당하는 것이다. 쉽게 말해 데이터와 그 데이터의 처리로직이 한 객체에 묶여있는 것. Information Expert는 캡슐화를 통해 내부적으로 데이터를 처리하고 외부적으로는 기능만 제공한다.

### 2. GRASP 책임 할당 지침 중에서 High Cohesion에 대해 설명할 수 있는가?
  - High Cohesion이란 각 객체가 밀접하게 연관된 기능들을 가지도록 구성하는 것이다. 한 객체가 부여받은 책임만을 수행하도록 구성하면 자연스럽게 Low Coupling이 된다.

### 3. 상속 관계에 있는 클래스를 가리킬 때 용어를 설명할 수 있는가?
  - 상위클래스를 수퍼클래스 또는 부모클래스
  - 하위클래스를 서브클래스 또는 자식클래스

### 4. 상속 관계에 있는 클래스의 인스턴스를 다룰 때 레퍼런스를 선언하는 방법을 아는가?
  - 일반적으로 자식클래스가 상위 클래스를 레퍼런스로 지정할 수 있다.
  - 다른 클래스 관계에 있거나 상위클래스가 하위클래스를 레퍼런스로 선언할 수 없다.

### 5. 인터페이스 레퍼런스에 저장할 수 있는 인스턴스에 대해 설명할 수 있는가?
  - 인터페이스 레퍼런스에 저장할 수 있는 인스턴스는 해당 인터페이스 규칙에 따라 작성된 클래스의 인스턴스(객체)만 저장할 수 있다. 


# 22일차 (2023-12-13, 수)
### 1. 제네릭의 용도를 설명할 수 있는가?
  - 레퍼런스를 선언할 때 지정한 타입을 리턴하도록 제한하는 문법이다. 
  - 제네릭을 사용하지 않은 코드는 객체를 다룰 때 형변환을 수행해야 하지만 제네릭을 사용하면 컴파일러가 자동 타입 변환을 처리하므로 재사용성과 안전성이 높아진다.

### 2. 제네릭을 적용하여 클래스를 정의하고 사용할 수 있는가?
  - 클래스 리턴타입 오른쪽에 <리턴타입>을 작성한다.
  - 객체 생성 시에도 <리턴타입 작성>, 객체오른쪽에도 <>는 꼭 붙여야 한다. 
  - 메서드에는 리턴타입 대신 제네릭명을 작성한다.
  - 메서드가 제네릭으로 선언되었을 때는 반환되는 값의 실제 타입이 컴파일 시에는 알 수 없기 때문에 형변환을 해주어야 한다.


# 23일차 (2023-12-14,목)
### 1. 생성자의 역할을 설명할 수 있는가?
  생성자는 객체를 생성할 때 인스턴스를 유효한 상태로 초기화하고 필요한 작업을 수행하는 특별한 메서드이다. 

### 2. String의 다양한 생성자를 사용하여 인스턴스를 생성할 수 있는가?
  - String 클래스의 문자열 리터럴, char[] 배열, byte[] 배열 생성자를 활용하여 인스턴스를 초기화할 수 있다. 
  - String 객체를 생성할 때 파라미터 값으로 문자열 리터럴 혹은 char/byte 배열을 전달하면 된다.

### 3. Singleton 패턴의 용도를 이해하고 구현할 수 있는가?
  - Singleton 패턴이란 객체를 하나만 생성하고 유지하기 위한 설계 기법이다.
  - 일반적으로 외부에서 생성자에 접근할 수 없도록 private으로 제한하고 getInstance 메서드를 만들어서 해당 객체가 없으면 new를 통해 객체를 생성한 후 리턴하고 있으면 해당 객체를 리턴하도록 한다. 

### 4. Factory Method 패턴의 용도를 이해하고 구현할 수 있는가?
  - 객체생성 코드가 복잡할 때 캡슐화를 통해 코드를 단순하게 만드는 설계 기법이다.
  - ?

### 5. 인스턴스 메서드와 스태틱 메서드를 구분하여 사용할 수 있는가?
  - 스태틱 메서드는 인스턴스를 필드를 사용하지 않고 파라미터 값만으로 작업을 수행하거나 클래스 수준에서 작업을 수행하는 경우 사용한다.
  - 인스턴스 메서드는 인스턴스 필드에 접근해야 하거나 특정 객체의 속성이나 상태를 활용할 경우 사용한다.
  - 일반적으로 인스턴스 메서드로 선언해놓고 필요에 의해 스태틱 메서드로 전환하는 방식이 유용하다. 

### 6. 상속의 용도를 이해하고 구현할 수 있는가?
  - 상속은 기존 코드의 재사용성을 높이고 다형성을 활용하기 위해 사용된다. 
  - 예를 들어 특정 기능을 추가하기 위해 기존 코드를 수정하거나 복사하는 경우 코드 중복 또는 에러의 위험이 있기 때문에 상속을 통해 슈퍼클래스의 기능을 받아 추가적인 기능을 구현을 할 수 있다.
  - 하위클래스에서 '하위클래스명 extends 상속할 수퍼클래스명' 으로 상속받을 수 있다. 
  - 하위클래스에서는 수퍼클래스의 메서드를 자유롭게 호출하여 사용이 가능하다.

# 24일차 (2023-12-15,금)
### 1. 다형적 변수의 사용법을 이해하는가?
  - 하위클래스 인스턴스를 상위 클래스의 레퍼런스로 가리킬 수 있다. 다만 해당 상위클래스 레퍼런스 타입의 인스턴스 멤버만 접근할 수 있다. 

### 2. 다형적 변수의 형변환 하는 경우를 설명할 수 있는가?
  - 하위클래스 인스턴스를 상위 클래스의 레퍼런스로 지정할 경우 하위 클래스 인스턴스 멤버를 사용하기 위해서는 형변환을 사용하여 해당 하위클래스 레퍼런스로 타입을 변경하여야 한다.
  - 상위클래스 인스턴스를 지정한 경우 형변환을 하여도 해당 인스턴스가 없기 때문에 컴파일 에러가 발생한다.

### 3. instanceOf 연산자와 getClass()의 사용법을 설명할 수 있는가?
  - instanceOf
    - 레퍼런스에 들어있는 주소가 특정 클래스의 인스턴스인지 검사한다.
    - 상속관계에 있는 부모/자식 클래스 모두 검사한다.
    - 따라서 정확히 어떤 클래스인지는 확인불가능
  - getClass()
    - 레퍼런스가 가리키는 인스턴스의 실제 클래스 정보를 리턴한다.
    - == 연산자를 사용하여 특정클래스의 인스턴스인지 확인가능
    - 클래스명.class는 클래스 정보를 갖고 있는 스태틱 변수이다

### 4. 오버로딩을 설명할 수 있는가?
  - 같은 작업을 수행하지만 파라미터가 다른 경우에도 동일한 메서드명을 사용하여 프로그래밍 일관성을 제공하기 위한 문법이다.
  - 파라미터 형식에 따라 구분한다. 

### 5. 오버라이딩을 설명할 수 있는가?
  - 상속받은 메서드를 서브클래스의 역할에 맞게 재정의하는 문법
  - 동일한 메서드 시그니처로 작성한다.

### 6. this와 super 레퍼런스를 통해 필드나 메서드를 사용하는 방법을 아는가?
  - this 레퍼런스는 실제 인스터스가 소속된 클래스부터 메서드를 찾아 올라간다.
  - super 레퍼런스는 호출된 메서드가 존재하는 클래스의 수퍼클래스부터 찾아 올라간다.


</span>