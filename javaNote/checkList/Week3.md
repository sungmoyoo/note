# 학습점검목록 3주차
<span style="font-size:120%">

# 10일차 (2023-11-27,월)
### 1. 상수를 만들고 사용할 수 있는가?
  - final
```
final 데이터타입 변수명 = 값;
```

  - enum
```
enum 메서드명{
  변수명1, 변수명2, 변수명3
}

Level level = Level.변수명1
레퍼런스 변수명   메서드명
```

### 2. 블록과 연결해서 변수의 사용범위를 설명할 수 있는가?
  - 블록 바깥에서 선언한 변수는 블록 안에서 사용할 수 있지만, 블록 안에서 선언한 변수는 블록 실행이 종료된 후 제거되어 사용할 수 없다.

### 3. 문자열 작성된 값을 해당 타입으로 변환하는 방법을 알고 있는가?
  - .valueOf()를 사용하여 변환할 수 있다.
  - .valueOf(), .parse(type) 두 가지 존재
```
int i = Integer.valueOf("3")
float f = Float.parseFloat("3.14")
```

### 4. 산술 연산자의 종류와 사용법을 설명할 수 있는가?
  - 산술연산자의 종류에는 '+, -, *, /, %' 가 있다.
```
a = 1+3 -> 덧셈
b = 2-1 -> 뺄셋
c = 1*2 -> 곱셈
d = 2/1 -> 나눗셈, 정수일 경우 소수점까지 계산 안한다.
e = 3%2 -> 나누고 난 나머지
```

### 5. 암시적 형변환이 일어나는 경우를 설명할 수 있는가?
  - 서로 다른 데이터타입인 경우 연산을 위해 암시적 형변환이 발생한다.
  - byte, short 타입의 경우 기본 연산단위가 int이므로 연산 시에는 int 이상의 데이터 크기로 형 변환이 일어난다.

### 6. 명시적 형변환이 필요한 시점과 주의할 점을 설명할 수 있는가?
  - 필요 시점
    - 큰 메모리의 값을 작은 메모리로 변환할 때
    - 부동소수점을 정수로 변환할 때
  - 주의점
    - 부동소수점을 변환할 때는 소수점이 그냥 잘려버린다.
    - 메모리의 크기를 벗어나는 큰 수의 값을 저장하려고 하면 앞의 바이트가 잘리고 뒤에 바이트만 저장된다.

### 7. 관계 연산자의 종류와 사용법을 설명할 수 있는가?
  - 관계연산자의 종류에는 '>,<, >=, <=, ==, !=' 가 있다.
  - 관계연산자는 오직 boolean 타입을 결과로 리턴한다.(true or false만 존재)
```
a<b -> a가 b보다 작다
a>b -> a가 b보다 크다
a<=b -> a가 b보다 작거나 같다
a>=b -> a가 b보다 크거나 같다
a==b -> a와 b가 같다
a!=b -> a와 b가 같지 않다.
```

### 8. 부동 소수점을 관계연산자로 비교할 때 발생할 수 있는 문제점 및 해결방안을 설명할 수 있는가?
  - IEEE 754 명세에 따라 부동소수점이 이진수로 변환되는 과정 중 정규화 과정에서 정수로 딱 맞아떨어지지 않는 경우가 발생한 경우 극한의 미세 소수점이 생긴다. 이 때 같은 수의 비교가 불가능하다.
  - 비교하는 두 값의 차의 절댓값 임의의 미세소수점보다 작다면 극소수의 값을 무시할 수 있다.

```
double EPSILON = 0.000000001;
Math.abs((a+b)-(x+y) < EPSILON);
```

### 9. 논리 연산자의 종류와 사용법을 설명할 수 있는가?
  - 논리연산자에는 '&&, ||, !, ^' 가 있다.
```
논리값 && 논리값 -> 두 논리값 모두 참일 경우 true 리턴
논리값 || 논리값 -> 두 논리값 중 하나만이라도 참일 경우 true 리턴 
!논리값 -> true는 false로 false는 true로 바꾼다.
논리값 ^ 논리값 -> 두 논리값이 서로 다르면 true 리턴
```

### 10. 논리 연산자 && 와 $, || 와 |의 차이점을 설명할 수 있는가?
  - && 또는 || 연산은 논리 왼쪽 값(문장)에 의해 결과가 확정될 경우 오른쪽 문장을 실행하지 않고, & 그리고 | 연산은 끝까지 실행한다.
  - 또 && ||는 정수연산이 안되지만, &과 |는 정수연산이 가능하다(비트연산자)

### 11. 비트 연산자의 종류와 사용법을 설명할 수 있는가?
  - 비트 단위의 연산을 수행한다. '&, |, ^, ~'가 있다.
```
a & b -> 매칭되는 비트가 모두 1인 경우에 1을 리턴한다.
a | b -> 매칭되는 비트 중 하나라도 1이면 1을 리턴한다.
a ^ b -> 두 비트가 서로 다르면 1을 리턴한다.
~a -> 1은 0으로 0은 1로 반전시킨다.
```

### 12. 비트 연산자 & 와 |를 응용하여 수행할 수 있는 작업을 설명할 수 있는가?
  - 일반적으로 이미지, 동영상 편집 기법으로 사용된다.
  - 마스킹, 오버레이 등 색상 추출, 강화하는데 유용하다.
  - 또는 % 연산을 구현할 수도 있다. (더 빠름)

### 13. 비트 이동 연산자의 종류와 사용법을 설명할 수 있는가?
  - 비트 이동 연산자에는 '>>, <<, >>>'가 있다. 

```
i << (비트수) 
- 왼쪽으로 비트 수만큼 이동한다.
- 왼쪽 초과된 비트는 자르고, 오른쪽 빈칸은 0으로 채운다.
- n비트 이동 시 2^n만큼 곱한 것과 같다.
- 음수의 경우 양수로 바뀔 수도 있다.

i >> (비트수)
- 오른쪽으로 비트 수만큼 이동한다.
- 오른쪽 초과된 비트는 자르고, 빈칸을 부호비트로 채운다.(양수 0, 음수 1)
- n비트 이동 시 2^n만큼 나눈 것과 같다. 

i >>> (비트수)
- 오른쪽으로 비트를 이동시킨다
- 빈자리는 음수양수 상관없이 무조건 0으로 채운다.
- 오른쪽 경계를 넘어간 비트는 자른다.
```

### 14. 비트 이동 연산자를 응용하여 수행할 수 있는 작업을 설명할 수 있는가?
  - 실무에서는 여러개의 true/false 데이터를 비트이동연산자를 활용하여 저장하기도 한다. 메모리 절약을 위해
  - 각각 4바이트의 크기를 갖는 8개의 true/false를 저장한다고 가정해보면 각각 32바이트를 사용해야 한다
  - 배열을 사용하면 요소당 1바이트씩 8바이트를 사용해야 한다
  - true/false를 이진수의 형태로 1비트씩 저장하면 4바이트로 32개의 요소를 저장할 수 있다.


# 11일차 (2023-11-28,화)
### 1. 조건연산자의 사용법을 설명할 수 있는가?
  - 조건의 결과가 참일 경우 왼쪽 표현식, 거짓일 경우 오른쪽 표현식을 리턴
  ```
  int age = 17;
  String a = age2 > 18 "성년" : "미성년";
  ``` 

### 2. statement와 expression을 설명할 수 있는가?
  - statement는 실행 가능한 코드 문장
  - expression은 statement 중 결과값을 리턴하는 문장..

### 3. 전위 연산자와 후위 연산자의 사용법을 설명할 수 있는가?
  - 전위연산자와 후위연산자는 연산순위에서 가장 우선으로 실행된다.
  - 전위연산자는 변수 앞에 ++를 붙여서 사용하며 +1을 먼저 한 다음 임시 변수인 temp에 저장된다.
```
i = 100;
System.out.println(++i);

-> i = i + 1
-> temp = i
-> System.out.printlm(temp)
출력값: 101
i값: 101
```
  - 후위연산자는 변수 뒤에 ++를 붙여서 사용하며 temp에 먼저 저장 후 +1 연산을 실행한다.
```
i = 100;
System.out.println(++i);

-> temp = i
-> i = i + 1
-> System.out.printlm(temp)
출력값: 100
i값: 101
```

### 4. 대입연산자의 사용법을 설명할 수 있는가?
  - '=, +=, -=, *=, /=, %=' 등이 있다.
  - =는 값 그대로 대입, 나머지는 동일 변수에 연산 후 변수값을 다시 대입한다.

### 5. if, switch문의 사용법을 설명할 수 있는가?
  - if문
  ```
  if (조건){
    문장;
  }
  ```

  - if else문
  ```
  if (조건){
    문장;
  }
  else{
    문장;
  }
  ```

  - switch ~ case문
  ```
  switch(판단값){
    case 값1:
      문장;
      break;
    case 값2:
      문장;
      break;
    default:
      문장;
  }
  ```
### 6. switch() 문에 사용할 수 있는 데이터 타입을 알고 있는가?
  - int정수, 문자열, enum상수

### 7. 상수를 표현할 때 final 대신 enum 방식의 이점을 설명할 수 있는가?
  - 직접 값을 지정하지 않아도 되고, 직접 지정할 수도 있다.
  - 정의된 값만 저장할 수 있기 때문에 코드의 안전성이 올라간다.

### 8. while, do ~ while, for 반복문의 사용법을 설명할 수 있는가?
  - while문
  ```
  while(조건){
    문장;
  }
  ```

  - do ~ while문
  ```
  do{
    문장;
  } while(조건);
  ```

  - for문
  ```
  for (변수 선언 및 초기화; 조건; 증감문){
    문장;
  }
  ``` 

### 9. 메서드를 실행할 때 값을 전달하는 방법을 알고 있는가?
  - 메서드의 값(아규먼트)에는 원시 데이터 타입 혹은 레퍼런스가 들어갈 수도 있고 객체가 들어갈 수도 있고, 메서드 안에 메서드가 들어갈 수도 있다. 


# 12일차 (2023-11-29,수)
### 1. 프로그램의 표준입력스트림, 표준출력스트림, 오류스트림을 설명할 수 있는가?
  - 표준입력스트림, 표준출력스트림, 오류스트림은 자바에서 데이터가 입/출력되는 출입구라고 보면 된다.
  - 데이터의 흐름은 표준입력스트림 -> 프로그램 -> 표준출력스트림,오류스트림 순서이다.
  - 표준입력스트림은 키보드 이외에도 다른 프로그램의 결과가 표준입력스트림이 될 수 있다. 
  - 표준출력스트림 또한 터미널, 다른 프로그램의 표준입력스트림, 파일 등 다양하게 연결할 수 있다.
  - 표준 오류 스트림은 프로그램 실행 중 발생한 오류를 내보낼 특별한 출구이다.
  - 위와 같은 스트림 말고도 사용자가 인위적으로 프로그램에 데이터 흐름을 제어할 수 있는 방법이 있는데 File I/O와 소켓이다. File I/O는 파일의 연결, 소켓은 외부 네트워크로 연결해준다. 이와 같은 방법으로 만든 스트림은 데이터 흐름이 양방향이다. 

### 2. Scanner 클래스를 사용하는 이유를 설명할 수 있는가?
  - Scanner 클래스에는 입력된 데이터를 다양한 형태를 가공해주는 메서드들이 들어 있기 때문에 사용한다. 

### 3. Scanner 클래스를 사용하여 키보드 입력을 처리할 수 있는가?
```
import java.util.Scanner (안하면 객체 생성시 붙여야 함)

Scanner keyIn = new Scanner(System.in);

System.out.println("enter: ")
keyIn.nextLine(); <- String 타입, 데이터를 읽은 후 줄바꿈 처리
keyIn.next(); <- 데이터를 토큰 단위로 읽어옴
keyIn.nextint(); <- String 데이터를 읽은 후 int 타입으로 변환해줌
...등등
```
### 4. for 반복문을 이용하여 배열의 값을 다룰 수 있는가?
  - 반복문과 인덱스를 활용하여 배열의 값을 제어할 수 있다.
```
int[] arrays = {1,2,3,4,5}

for (int i = 0 ; i < arrays.length ; i++){
  System.out.println(arr[i])
}

배열의 값을 모두 출력할 경우 for (:) 사용
for (int arr : arrays){
  System.out.println(arr)
}

컬렉션 사용
ArrayList list = new ArrayList();
list.add("홍길동")
List.add(3.14f)
List.add(true)
List.add(365)

for (int i = 0; i < list.size(); i++){
  System.out.println(list.get(i));
}
또는
for (Object value : list)
  System.out.println(value);
```

### 5. 기능 단위로 명령문을 묶어 사용할 수 있는가?
  - 메서드 사용


heap 영역 메모리 데이터는 jvm 종료되면 사라지나?
메서드 내에 statement가 없어도 stack에 frame이 생성되는지?


# 13일차 (2023-11-30,목)
### 1. 메서드를 정의하고 사용하는 방법을 설명할 수 있는가?
  - 메서드 정의:  
```
[리턴타입] 메서드명([파라미터]){
  실행문장
}
```
  - 메서드 호출:
```
[리턴타입] 메서드명([파라미터])
리턴 타입이 없으면 변수명만 사용, 파라미터도 없으면 생략
```

### 2. 메서드 시그니처(signiture)와 바디(body)를 설명할 수 있는가?
  - 메서드 시그니처는 메서드명과 파라미터 리스트의 조합을 의미하고, 메서드 바디는 메서드가 실행될 때 실질적으로 수행되는 코드 블록을 의미한다.

### 3. 메서드의 아규먼트와 파라미터를 설명할 수 있는가?
- 메서드 아규먼트는 전달하는 실질적 값을 의미하고 파라미터는 그 값을 받는 변수를 의미한다.

### 4. 가변 파라미터를 사용할 수 있는가?
- 가변 파라미터는 "[리턴타입] 메서드명(타입... 변수)"을 통해 사용한다. 일반적으로 0개 이상의 값을 받을 때 사용하며 내부적으로는 배열처럼 사용된다. 만약 배열을 전달할 경우 그 배열을 그대로 받아 사용한다.

### 5. 가변 파라미터와 배열 파라미터의 특징을 비교 설명할 수 있는가?
- 가변 파라미터는 여러 개 사용할 수 없고 파라미터 맨 끝에만 올 수 있는데 반면 배열 파라미터는 이러한 제약이 없다.

### 6. call by value와 call by reference를 비교 설명할 수 있는가?
메서드를 호출할 때 primitive data type, 즉 8가지의 원시 타입을 아규먼트로 전달할 경우 call by value이고 나머지는 모두 call by reference로 아규먼트로 주소를 전달하는 형태이다.

### 7. JVM이 관리하는 메모리 영역을 용도에 따라 설명할 수 있는가?
  - method area:  
  바이트코드(클래스)와 static field를 보관하는 메모리 영역
  
  - stack:  
  로컬 변수를 저장하는 메모리 영역 메서드가 호출될 때 frame을 생성해 메서드별 로컬변수를 관리한다. 메서드가 종료되면 모두 제거된다.

  - heap:  
  new 명령을 통해 만든 변수(인스턴스)를 보관하는 메모리 영역 메서드 종료 이후에도 제거되지 않기 때문에 Garbage Collector가 참조되지 않는 메모리를 관리한다.

### 8. 재귀호출을 다룰 수 있는가?
  - 재귀호출은 함수 내부에서 함수가 자신 자신을 또다시 호출하는 것을 의미한다. 자기 자신을 끝없이 호출하므로 함수 내에 재귀호출을 중단하도록 조건을 삽입해주어야 한다.
```
ex)
int sum (int value) {
  if (value == 1)
    return 1
  return value + sum(value - 1);
}
```

### 9. 스택오버플로우 오류를 설명할 수 있는가?
  - 스택오버플로우는 JVM 메모리 용량이 꽉 차서 더이상 메서드 실행에 필요한 로컬 변수를 만들 수 없을 때 발생하는 오류이다. 메모리 용량에 영향을 미치는 요인에는 frame도 포함된다.


# 14일차 (2023-12-01,금)
### 1. main() 메서드의 파라미터를 통해 프로그램 아규먼트를 다룰 수 있는가?
  - 프로그램 아규먼트는 JVM을 실행할 때 전달하는 값이다. main() 메서드에서 args가 이에 해당한다.
  - 자바 실행 시 값을 넘기기 위해 사용한다.
  - 프로그램 아규먼트는 스트링 배열에 담겨서 넘어돈다.
  - 공백을 기준으로 잘라서 배열을 만든다.
  - 아규먼트가 없으면 빈 배열이 넘어온다.
```
Java -cp bin/main com.eomcs.Exam aaa bbb ccc
aaa bbb ccc 가 사용자가 지정한 프로그램 아규먼트이다.
```
### 2. Properties 객체를 통해 JVM 아규먼트를 다룰 수 있는가?

### 3. 메서드를 이용하여 기능 단위로 명령문을 묶어서 다룰 수 있는가?
  - 리턴타입 메서드명(파라미터) {--} 로 메서드 생성
  - 호출 시 메서드명(아규먼트); 로 사용

### 4. 클래스를 이용하여 서로 관련된 메서드를 묶어서 다룰 수 있는가?
  - 클래스를 통해 서로 관련된 메서드를 묶어서 하나의 기능을 할 수 있도록 분류할 수 있다.
  - 별도의 클래스 파일 생성 후 메서드를 묶어서 저장, 이때 참조에 관한 부분을 유의해야 한다.
  - 클래스를 호출할 때는 클래스명.메서드명(파라미터);로 호출한다.

### 5. GRASP의 'High Cohesion' 패턴에 대해 설명할 수 있는가?
  - High Cohesion은 데이터를 다루는 곳(연산)에 데이터를 둠으로써 유지보수를 쉽게 하는 설계 기법이다. 즉 서로 관련있는 기능을 묶는 것을 의미한다.

### 6. GRASP의 'Low Coupling' 패턴에 대해 설명할 수 있는가?
  - Low Coupling은 클래스 간의 의존성을 나타내는 결합도를 낮다는 것을 의미한다. 낮은 결합도를 가진 시스템은 유지보수가 쉽고 재사용이 용이하다.

### 7. GRASP의 'Information Expert' 패턴에 대해 설명할 수 있는가?
  - Information Expert는 특정 작업을 하는 클래스가 작업에 필요한 정보를 가지는 것이 좋다는 개념을 나타낸다. 쉽게 말해 데이터를 다루는 곳에 데이터를 두는 것이다.
</span>