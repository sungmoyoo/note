# 학습점검목록 7주차
<span style="font-size:120%">

# 30일차 (2023-12-26,화)
### 1. 예외처리의 고전적인 방식과 한계를 예를 들어 설명할 수 있는가?
  - 예외처리의 고전적인 방식은 리턴값을 활용하는 방식이다. 예를 들어 유효성 검사를 통해 무효한 값인 경우 -1과 같이 특정 값을 리턴하도록 한다.
  - 고전방식의 한계는 리턴값이 실제 저장된 값인지 유효하지 않은 값인지 구분할 수 없다는 점이다.

### 2. 예외 상황을 알리는 방법을 설명할 수 있는가?
  - 예외 상황은 메서드 선언부에 throws 예외클래스를 선언하고, 메서드 바디에서 throw [throwable 객체] 명령어를 사용하여 예외 상황을 던질 수 있다.

### 3. Error 클래스와 Exception, RuntimeException 클래스에 대해 설명할 수 있는가?
  - Error: System 예외이다. Error의 서브클래스는 xxxError로 끝나며, 일반적으로 예외 처리를 하지 않지만 하게 될 경우 메서드 선언부에 throws를 생략할 수 있다.

  - Exception: Application 예외이다. 서브클래스는 Exception으로 끝나며, 반드시 메서드 선언부에 throws를 선언해야 한다.

  - RunTimeException: Exception 계열의 예외이지만 unchecked exception이기 때문에 throws를 생략할 수 있다. 

### 4. 메서드가 던진 예외를 받는 방법을 설명할 수 있는가?
- try ~ catch ~ finally 문을 사용하여 받을 수 있다.
```
try {
  예외 발생 가능성이 있는 문장
}
catch (Exception E) {
  예외 상황을 받았을 때 실행할 문장
}
finally {
  try~catch 블록 나가기 전 무조건 실행하는 문장 
  ex) close()
}
```

### 5. try-with-resources 문법을 설명할 수 있는가?
 - 자동자원 해제를 지원하는 문법이다.
 
 - try {} 앞에 (변수 선언 = 객체 생성)을 넣어주면 사용할 수 있다.
 - java.lang.AutoCloseable 구현체에 대해서만 가능하다
 - 변수 선언만 올 수 없다.
 - 여러개도 지정 가능하다. 단 문장 사이는 세미콜론(;)으로 구분하며 마지막 문장은 세미콜론을 생략할 수 있다.

### 6. LinkedList(연결리스트)의 add()를 구현할 수 있는가?
- 31일차 학습점검목록에 통합 예정


# 31일차 (2023-12-27,수)
### 1. 연결리스트(LinkedList)의 동작 원리를 이해하고 구현할 수 있는가?
  LinkedList는 데이터 요소를 node에 순서대로 저장하는 자료구조이다. node 인스턴스에는 값을 저장하는 next와 다음 node의 주소를 저장하는 next로 구성되어 있다. 
  - add(value): node 생성하고 value 저장 후 first와 last 변수에 현 node주소 저장
  - toArray(): node = node.next로 하나씩 이동하며 value값 추출
  - get(): 값을 찾는 로컬 변수 int cursor를 설정하여 index까지 이동 후 해당 node value 리턴.
  - set(): get()과 동일하게 이동하여 value값 교체 후 기존 value값 리턴
  - add(index, value): 값이 없을 때, 인덱스가 1일 때, 인덱스가 마지막일 때, 중간값일 때 조건을 나누어 구현
  - remove(value): 주어진 value값과 일치할 때까지 노드 이동, 해당 노드가 참조하는 주소를 null로 바꾸고 이전 노드인 prevNode와 뒷 노드를 연결하여 가비지로 만든다.
  - toArray(arr): 주어진 배열이 노드 사이즈보다 작으면 해당 사이즈 크기의 배열을 복사한 다음 값을 하나씩 담에 리턴

### 2. 제네릭을 적용하고 사용할 수 있는가?
  - 클래스 선언부에 제네릭 적용
  - 타입에 제네릭 적용
  - 리턴값에 제네릭 적용

### 3. 중첩클래스를 적용하고 사용할 수 있는가?
  - 클래스 내부에 클래스 작성
  - 만약 바깥 클래스의 인스턴스 변수를 사용하지 않을 경우 static 선언


# 32일차 (2023-12-28,목)
### 1. 인터페이스를 이용하여 객체 사용 규칙을 정의할 수 있는가?
  - 해당 인터페이스를 구현하는 클래스에서 사용할 메서드의 기능과 이름이 동일하다면 인터페이스에서 규칙을 정의하고 구현할 클래스에 implements 선언 

### 2. 인터페이스를 활용할 때 이점을 설명할 수 있는가?
  - 객체 사용 규칙을 명시함으로써 그 메서드를 구현한 어떤 클래스든 교체하기 쉽도록 할 수 있다.

### 3. 인터페이스와 추상클래스를 결합하여 활용하는 방법을 설명할 수 있는가?
  - 만약 공통으로 사용되는 메서드(기능)이 존재한다면 인터페이스를 추상클래스에서 구현하고 공통기능을 해당 클래스에서 구현 후 서브클래스로 상속해주면 된다. 

### 4. 자료구조 Stack과 Queue의 동작원리를 이해하고 구현할 수 있는가?
  Stack은 LIFO 방식의 자료구조로 마지막으로 넣은 데이터가 가장 먼저 제거되는 구조이다. 
  - push(value): 스택 요소를 추가한다. 맨 위에 쌓인다.
  - pop(): 스택의 맨 위에 있는 요소를 제거한다. 제거되는 요소의 value를 리턴한다.
  - peek(): 스택의 맨 위에 있는 요소를 조회한다. 제거되지 않고 value만 리턴한다.
  - empty(): 스택이 비어있는지 여부를 판단하여 true/false를 리턴한다.

  Queue는 FIFO 방식의 자료구조로 가장 먼저 추가된 데이터가 가장 먼저 제거되는 구조이다. 
  - add(value): 큐에 요소를 추가한다. 큐에 요소를 추가하지 못하는 경우 IllegalStateException 예외를 발생시킨다.
  - offer(value): 큐에 요소를 추가한다. 큐에 요소를 추가하지 못하는 경우 예외를 발생시키지 않고 false를 리턴한다.
  - poll(): 큐의 맨 처음 값을 제거한다. 제거되는 요소의 value를 리턴한다.
  - peek(): 큐의 맨 처음 값을 조회한다. 제거하지 않고 value만 리턴한다.

### 5. Stack과 Queue를 활용하는 예를 설명할 수 있는가?
  - Stack: 웹브라우저, 파일탐색기 등 breadcrumb 방식에 사용
  - Queue: 예약리스트 목록에 사용

### 6. GoF Factory Method 디자인 패턴을 설명하고 구현할 수 있는가?
  - 객체 생성을 서브 클래스에서 처리하도록 하는 기법, 객체 생성과정이 복잡할 때 캡슐화를 통해 단순화하는 것이 목적이다. 
  - 음 어렵다..

질문2
Factory Method 디자인패턴 적용..

# 33일차 (2023-12-29,금)
### 1. GoF의 Iterator 디자인 패턴의 용도를 설명할 수 있는가?

### 2. Iterator 디자인 패턴을 구현할 수 있는가?

### 3. 중첩 클래스를 설명할 수 있는가?
  - 특정 클래스에서만 사용할 클래스를 따로 둔다면 생성자를 생성해서 값을 넘겨주어야 하는 번거로움이 있다. 
  - 스태틱은 외부 인스턴스를 사용할 필요가 없을 때 사용한다.
  - 이때 논스태틱 중첩클래스를 활용하면 컴파일할 때 바깥클래스의 객체 주소를 this변수로 가져오므로 코드를 더 간결하게 작성할 수 있다.
  - 익명클래스는 클래스가 짧을 때 효과적, 코드가 복잡해지면 중첩클래스를 사용하지 않고 패키지 멤버 클래스로 두는 게 더 가독성이 좋다.

### 4. 로컬 클래스/익명 클래스를 설명할 수 있는가?


</span>
