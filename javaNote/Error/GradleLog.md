# 도입

공부한 내용을 정리하고 강사님께서 주신 예제 코드와 주석을 보며 복습하다가 갑자기 맥북의 용량이 부족하다는 알림을 받았다..

자세히 들어가서 살펴보니 공개된 파일에는 400GB를 초과하는 대용량 파일이 나타나지 않아서 시스템 업데이트로 인한 일시적 버그인가 생각했다.

<br></br>

# 문제의 원인 찾기
재시동을 해도 터지려는 저장 공간은 그대로였고 결국 직접 찾아보기로 했다.
구글링을 통해 간추린 원인은 2가지였다. 

**첫째, 대용량의 로그파일이나 캐시파일이 생성된 경우**
**둘째, 특정 응용프로그램이 생성하는 임시 파일이 생성된 경우**


문서 파일이 맞다면 숨겨져 있는 파일일 가능성이 높다.
어떤 파일이 용량을 많이 차지하는지 확인하기 위해 터미널에서 관리자 모드로 전체 검색을 실행하였다.

![](https://velog.velcdn.com/images/samyoo644/post/2db97689-eded-4a4d-9e02-3c0d725bbfb8/image.png)

```
// 관리자 모드 진입
sudo -i

// 해당 디렉토리에 있는 파일들의 용량을 확인한다.
du -sh ./*

// 용량이 큰 파일부터 정렬 
du -sh ./* | sort -rh
```

<br>

![](https://velog.velcdn.com/images/samyoo644/post/5cb932d9-d743-406f-b384-c7af8389f133/image.png)


root 폴더에서부터 용량을 확인하여 cd를 타고 올라가니 library에 존재하는 숨김 파일에 있다는 것까지만 나오고 더 확인할 수 없어서 이때부터는 finder를 사용해 찾았다. 

![](https://velog.velcdn.com/images/samyoo644/post/d0991923-2f96-4b3d-a7c9-103968cfbfd1/image.png)


<br></br>

# 결과
![](https://velog.velcdn.com/images/samyoo644/post/9e6c7875-3094-41b9-8ddc-0312b6411777/image.png)

범인을 찾았다.. 
아래 경로에 있는 로그 파일 하나가 무려 435.77GB의 용량을 가지고 있었다.

`.gradle/daemon/8.5/daemon-2540.out.log`

용량 문제는 해당 로그 파일을 삭제하면 해결된다.

<br></br>

# 그래서 원인?
로그를 살펴보면 생성 시간은 오늘 오후 4시쯤 생성되었고 인텔리제이에서 `gradle run`을 실행시킬 때 발생하는 로그임을 확인했다.

세부 로그를 확인해보니 교육과정에서 배우는 강의 실습 프로젝트인 CRUD 프로그램이 무한으로 반복되면서 용량이 커진 것 같다.

![](https://velog.velcdn.com/images/samyoo644/post/76b317dd-3fc3-42f2-b379-c580ebc40ca0/image.png)

여기서 문제는 오늘 바꾼 소스 코드는 다중 클라이언트 요청을 처리하기 위해 멀티 스레드를 적용한 몇 줄 안되는 코드인데 다시 실행해보아도 동일한 문제가 발생하지 않는다는 것이다.

그 당시 어떤 과정을 통해 해당 로그가 발생했는지 기억이 나지 않아 정확한 원인을 확정짓지는 못하겠으나 클라이언트 클래스를 실행시키기 전 오타가 난 코드로 인해 발생한 문제로 추측하고 있다.

<br>

해당 문제에 대한 나의 충실한 사이버 비서 채짚히티씨의 의견은 다음과 같다.

1. **서버의 무한 루프:**
   - `while (true)` 루프가 있는 `run` 메서드에서 클라이언트 요청을 계속해서 받고 처리하고 있습니다. 이 루프에서 서버 소켓이 계속해서 클라이언트 연결을 받아들이기 때문에 무한 반복이 발생할 수 있습니다.
   - 서버를 정상적으로 종료하려면 클라이언트와의 통신을 끝내고 `serverSocket.close()` 등으로 서버 소켓을 닫아야 합니다.

2. **클라이언트의 비정상 종료:**
   - 클라이언트가 비정상적으로 종료되면 `DataInputStream`의 `readUTF` 메서드에서 예외가 발생할 수 있습니다. 이 경우에도 서버에서 예외가 발생하고 무한 반복이 될 수 있습니다.
   - 클라이언트에서 소켓을 닫는 등의 정상적인 종료 조치를 취해야 합니다.

3. **서버의 예외 처리 부족:**
   - 서버에서 발생하는 예외를 적절하게 처리하고 로그를 남겨야 합니다. 현재 코드에서는 예외가 발생할 경우 그에 따른 처리가 제한적으로 이루어지고 있습니다.
   - 각 예외 상황에 대한 적절한 처리와 로깅을 추가하여 디버깅에 도움을 받을 수 있습니다.

4. **스레드 관리:**
   - 클라이언트의 연결을 처리하기 위해 새로운 스레드를 생성하고 있습니다. 스레드를 안전하게 관리하지 않으면 스레드의 비정상 종료로 인해 문제가 발생할 수 있습니다.
   - 스레드 풀을 고려하거나, 스레드 생성 및 종료 시 안전한 방법을 고려해보세요.

로그 파일이 너무 크다면 예외가 발생하는 부분에서 무한 반복되는 로그가 기록되고 있을 가능성이 높습니다. 따라서 예외 처리 및 디버깅을 강화하여 문제를 해결해보세요.

<br>


\+추가
: 인텔리제이에서 실행을 강제로 종료하는 경우 프로세스가 완전히 종료되지 않고 내부적으로 실행되는 상황에서 다시 클라이언트를 실행하는 경우도 있다고 한다..

<br></br>

>혹시라도 원인을 아시는 분이 계신다면 댓글로 한번만 알려주시면 감사하겠습니다.. 🙇‍

