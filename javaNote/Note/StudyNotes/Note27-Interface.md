<span style="font-size:133%">

# 인터페이스
1. 사용 전  
- 프로그래밍 개념에서는 사람,사물을 객체로 추상화하여 다룬다.
- 메서드는 일을 전달하는 메세지 또는 연산자로 간주한다. 따라서 메서드는 동사구형태를 가진다.
- 만약 유사한 일을 하는데 객체 사용법이 다르면 각각 호출해야 하는 메시지가 다른 것이라 프로그래밍이 일관성이 떨어진다.
- 따라서 객체 사용 규칙을 정의하고 클래스를 정의할 때 그 규칙에 따라 만드는 문법이 "인터페이스"이다.

2. 사용 후  
- 사용법이 통일되었다 => 유지보수가 쉽다.
- callee = 구현체, caller = client, interface = 규칙
- 내가 interface를 구현해야되는 입장인지 구현체를 호출하는 client를 만드는 입장인지 빨리 파악하는 것이 중요하다.

### 인터페이스 레퍼런스
- 인터페이스를 구현한 클래스의 객체 주소를 저장하는 변수
```
=> Worker 사용규칙에 따라 작성된 클래스의 인스턴스 주소를   저장하는 변수 w.
=> Worker 인터페이스를 구현한 클래스의 인스턴스 주소를 저장하는 변수 w.
=> Worker 구현체의 인스턴스 주소를 저장하는 변수 w.
=> Worker 구현체의 객체 주소를 저장하는 변수 w.
=> Worker 구현 객체를 저장하는 변수 w.
=> Worker 객체를 저장하는 (변수) w.
=> Worker 객체를 가리키는 (변수) w.
=> Worker 타입 객체 w.
```

## 인터페이스 정의
- 인터페이스에 선언되는 모든 메서드는 public
- public abstract 생략 가능

## 인터페이스 구현
- 인터페이스는 여러 개를 적용할 수도 있다.
- public보다 접근 범위를 좁힐 수 없다.
- 인터페이스의 모든 메서드를 구현해야 한다.
  - 한 개라도 빠지면 concrete클래스가 될 수 없어 추상클래스로 선언해야 한다.
- 반드시 implements로 인터페이스를 이행하겠다고 선언해야만 인터페이스 공식 구현체가 된다.

## 인터페이스 사용
ex09.exam01
- 인터페이스

## 인터페이스 필드 선언
- 인터페이스 필드는 public static final
  - 인스턴스 생성할 수 없기 때문에 인스턴스 필드를 선언할 수 없다.
  - 인스턴스 필드가 아니기 때문에 값을 변경할 수 없다.

## 인터페이스 필드 사용
- 인터페이스에 선언한 필드는 public static final이기 때문에 클래스명으로 바로 사용할 수 있다.
- 값 변경 불가

## 인터페이스 - default method
default [리턴타입] 메서드명() {}
- 이전에 작성한(구현한) 클래스에 영향을 끼치지 않으면서 규칙을 추가하는 문법
- 인터페이스에서 미리 구현한 메서드이기 때문에 클래스에서 구현(오버라이딩)을 생략할 수 있다.
- 구현을 강제할 수 없다는 것이 단점이다.

## 인터페이스 - private method
private [리턴타입] 메서드명() {}
- 인터페이스 내부에서 사용할 메서드라면 private 접근 범위를 갖는 구현 메서드를 정의할 수 있다.

## 인터페이스 - static method
static [리턴타입] 메서드명() {}
- 접근 범위는 기본이 public이다. 다른 접근 범위를 가질 수 없다.
- 인터페이스의 스태틱 메서드는 클래스의 스태틱 메서드를 호출하는 것과 똑같다. 클래스명.메서드명() = 인터페이스명.메서드명()
- 수퍼 클래스에 정의된 static 메서드는 서브클래스를 통해 호출할 수 있다. 그리고 그 서브클래스의 레퍼런스를 통해 호출할 수도 있다.

- 인터페이스에 정의된 스태틱 메서드는 인터페이스를 구현한 클래스를 통해 호출할 수 없다. 또 구현체의 레퍼런스를 통해서는 인터페이스의 스태틱 메서드를 호출할 수 없다.

## 인터페이스 - 상속
기존 규칙에 새 항목 추가할 때 새 규칙에 구현을 강제하고 싶을 때는 상속을 사용한다.
- 클래스처럼 새 인터페이스를 생성하고 상속한다.
- 서브 인터페이스에 정의된 규칙은 추상메서드이기 때문에 반드시 구현해야 한다.
- 수퍼 인터페이스의 추상메서드도 반드시 구현해야 한다.
- 메서드를 호출할 때는 컴파일 형식에 맞춰서 호출해야 한다. 예를 들어 인터페이스 레퍼런스로 구현체의 주소를 받았다면 해당 인터페이스에 정의된 규칙(메서드)에 따라서만 호출할 수 있다. 

## 인터페이스 - 다중 상속
인터페이스는 클래스와 다르게 다중 상속이 가능하다.
- 다중 상속한 수퍼 인터페이스의 메서드 모두 구현해야 한다.
- 수퍼인터페이스의 메서드가 중복되도 상관없다. 왜 why? 구현되지 않은 메서드이기 때문이다.
- 수퍼 인터페이스의 메서드 시그니처에서 이름, 파라미터는 같지만 리턴타입만 다를 경우 다중 상속이 불가능하다. 왜 why? 리턴타입만 다른 메서드를 여러개 오버로딩 할 수 없기 때문이다.

## 인터페이스 - 다중 구현
인터페이스는 구현하지 않은 메서드만 존재하기 때문에 다중 구현이 가능하다.
- 다중의 규칙을 모두 만족하는 메서드가 가능하다는 의미이다.
- 메서드 이름만 같고 파라미터, 리턴타입이 다른 경우 다중 구현이 불가능하다. 왜 why? 두 인터페이스를 모두 만족시키지 못하기 때문이다(오버로딩 규칙 위배).
- 메서드 시그니처가 다르다면 당연히 다중 구현 가능

## default method의 다중 구현
메서드가 구현된 경우 어느 메서드를 상속받아야 하는지 결정할 수 없기 때문에 다중 구현 불가

## 인터페이스와 추상클래스의 콜라보
- 인터페이스를 준수한다는 것은 인터페이스의 모든 규칙을 구현해야 함을 의미한다.
- 추상클래스에서 인터페이스의 규칙을 미리 최소상태로 모두 구현하고 서브클래스에서 상속받는다.
- 그 중에서 필요한 메서드만 오버라이딩을 통해 구현할 수 있다.

### 인터페이스 - 추상클래스 예
```
Servlet 인터페이스 {
  init()
  service()
  destroy()
  getServletInfo()
  getServletConfig()
}

GenericServlet 추상클래스 implements Servlet {
  init(){-}
  destroy(){-}
  getServletInfo(){-}
  getServletConfig(){-}
}

HttpServlet 추상클래스 extends GenericServlet {
  service() {-}
    service(){-}
      doGet(){-}
      doPost(){-}
}

MyServlet 일반클래스 extends HttpServlet {
  doGet(){-} 오버라이딩
  doPost(){-} 오버라이딩
}
```

# Object 클래스 
자바 최상위 클래스
- 클래스를 정의할 때 수퍼 클래스를 지정하지 않으면 컴파일러는 자동으로 Object를 상속받는다.

### Object 클래스와 instanceOf
instanceOf는 수퍼클래스의 경우에도 true가 나올 수 있다.
- 

## toString()
- 클래스 정보를 간단히 출력한다.
- 패키지명.클래스명@16진수해시값  
  
해시값?
- 인스턴스마다 부여된 고유의 식별자
- 인스턴스 주소가 아니다.

### toString() 오버라이딩
- 인스턴스의 현재 값을 간단히 확인하고 싶을 경우 toString을 오버라이딩하라
```
public String toString() {
  return "My [name=" + name + ", age=" + age + "]";
}
```

## .equals()
- 인스턴스가 같은지 비교하고 true/false를 반환

### .equals() 오버라이딩
- 인스턴스가 아닌 인스턴스의 내용물이 같은지 비교하고 싶으면 .equals를 재정의하라
- source/generate hashcord() and equals()
결론
- String와 wrapper 클래스는 equals() 오버라이딩 하였다.
- StringBuffer 클래스는 equals()를 오버라이딩 하지 않았다.
- String

exam134

## hashcode()
- Object에서 상속받은 hashCode()는 인스턴스마다 고유의 4바이트 정수값(Hash값)을 리턴한다.

### hash value?
```
1. 데이터 
  1byte..
2. 수학공식(algorithm)에 따라 계산 수행->Hash algorithm
  MD, MD5, SHA, PGP..
3. 32/64/128bit.. 값 으로 인코딩
위 과정에 따라 데이터에 해시값이 부여된다.
```

- 다른 데이터가 같은 해시값을 가질 수 있다. 
- 알고리즘이 좋을수록 같은 값을 가질 확률이 줄어든다.
  - 알고리즘이 좋다?
    - 복잡하고, 변환속도 느리고, 결과값이 커진다.

### Hash 값 활용 예
```
톰캣 서버 사이트 tomcat.zip -> PGP, SHA 해시값
local에 download한 tomcat.zip -> PGP, SHA 해시값
```
해시는 다운로드 받은 파일과 원본 파일의 해시값을 비교하는 용도로 사용된다. 만약 해커에 의해 파일이 변조되면 해시값이 다르게 나타난다.

# hashCode()
### 해시 값 충돌
```
1byte 데이터(256개) -----> 2bit 값(4개)
0000 0000 -------------> 00 hash값 충돌
0000 0001 -------------> 01
0000 0010 -------------> 10
0000 0011 -------------> 11
0000 0100 -------------> 00 hash값 충돌
```
- 데이터는 다른데 같은 hash값이 나온다
- 데이터 크기 보다 작은 크기의 숫자로 바꾸면 필연적으로 발생한다
결론
=> Hash값 크기가 크면 충돌가능성 낮아지고, 계산시간이 증가한다.

</span>

질문 

클래스가 인터페이스를 다중 상속 받을 수 있나?
