# 형상관리(Software Configuration Management)
형상관리는 소프트웨어의 변경사항을 체계적으로 추적하고 통제하는 것, 변경 이전과 이후 상태에 대한 세부 정보를 분석, 기록 하여 제어하고 품질보증활동을 향상시키는 기법
- 소프트웨어 형상이란 소프트웨어에서 관리되어야 할 항목들을 의미한다.
- 버전관리시스템은 이러한 형상항목들을 변경관리(tracking, controlling)하는 것
  
  
## 1. SCM 논문 정의
소프트웨어 형상관리는 소프트웨어 수명주기동안에 생성되는 시스템 내의 소프트웨어 항목을 식별, 정의, 제작, 수정, 배포하고 소프트웨어 항목에 대한 수정 요구를 보고하고 기록하는 행위를 기술적인 절차를 적용하여 하나의 프로세스로 관리하는 것.   
<br>

### 1.1 Software lifecycle(소프트웨어 수명주기)
- 소프트웨어 구성:  
프로그램 + 문서 + 설정파일
```
생성 --------> 유지보수 --------> 소멸
|--------------------------------|
          S/W lifecycle           
```
  
## 2. SCM 목적
- 산출물 품질 향상
- 개발 및 유지보수 생산성의 향상
- 사용자의 요구사항을 체계적으로 관리

## 3. 관리 항목
S/W 품질보증/관리 (QA/QM)
- 소스 관리(공유, 접근제어)
- 버전 관리(변경기록, 되돌림, 제품에 사용될 소스 관리)
- 빌드 구조, 개발 환경, 문서

=> 버전관리 시스템 ex)Git, SVN, CVS

### 3.1 빌드 과정
```
컴파일 -> 테스트 -> 문서 -> 패킹 -> 배포
          |
        보고서 
```

## 4. 버전관리시스템
형상 관리 분야에서 소스관리와 변경관리를 처리하는 프로그램

### 4.1 로컬 버전관리시스템
대표제품이 RCS(Revision Control System)
local(자신의 PC) <-> remote(다른 PC)
생성/변경/삭제의 사항들을 **로컬**에서 각 버전으로 나누어서 관리(되돌리기 가능)
- 다만, 팀원 간 공유 불가

### 4.2 중앙 집중식 버전관리시스템
서버에 소스파일을 기록, 소스파일을 가져와 편집
- 소스파일을 가져오는 것을 체크아웃(checkout), 다시 기록하는 것을 체크인(checkin)이라고 한다.  
<b style="color:red">모든 변경기록은 서버에 보관</b>

- 팀원 간 소스파일 공유 가능
- 중앙 서버 하나만 관리하면 됨
- 모든 변경기록이 서버에 보관, 만약 서버에 문제가 발생하면 변경기록이 날아감
- local에는 소스파일만 있고 변경기록이 없다. 
- <b style="color:red">소스파일 복구는 가능하지만 기록은 복구불가</b>

**CVS(Concurrent Version System)**
- 체크인 할 때 파일을 통째로 업로드하는 것이 특징
- 따라서 네트웍으로 주고 받는 양이 크다.

**SVN(Subversion)**
- 변경부분만 업로드한다.
- 따라서 통신량이 줄어든다. 

**Perforce**
도 있다. 

### 2.3 분산버전관리시스템(Git)
기록을 여러 컴퓨터에 분산보관
기록을 클론(복사)하여 로컬에 보관(용량 많이 안큼)
- 서버에 문제가 발생하더라도 원상복구 가능

# Git 사용법

## 1. clone
- Repository 복제(clone) 방법
```
$git clone https://github.com/사용자이름/주소
```
- clone은 복제체를 local에 생성하여 기록한다.
- 따라서 working directory와 숨겨진 .git으로 나뉨 <- 기록 보관

### 1.1 Repo. 디렉토리 구조
- /mystudy/ -.git/ 이 폴더가 변경기록을 보관하는 폴더 
.git은 절대 건들 ㄴㄴ
- 나머지는 working directory

## 2. add -> commit
- 저장소 보관
1. 백업할 대상 파일을 백업 명단에 추가, .git에 index가 그 명단
2. 백업한다. 
3. 백업시킨 것을 다른 팀원과 공유하고 싶으면 push를 사용,  
  push = 로컬저장소(.git)의 변경 내용을 서버 저장소에 업로드
```
1. $git add 대상확인
2. $git commit -m "백업내용"
3. $git push 
```
### 2.1 Git 파일의 상태 변화

다음은 Git 명령에 따른 파일의 상태 변화를 보여준다.
```
         Working Directory         | Staging Area | .git Directory(Repository)
[Untracked] [Unmodified] [Modified]|[   Staged   ]|[  Committed  ]    
-----------------------------------|--------------|---------------------------
    +------------------------------------->>                      : git add
    <<-------------------------------------+                      : git restore --staged
                              +----------->>                      : git add
                                           +------------->>       : git commit
                  <<-----------------------+                  
                  +---------->>                                   : 파일 편집
    <<------------+                                               : 파일 삭제
```
- **Untracked** - 작업 디렉토리에 새로 파일을 추가한 경우. 아직 스냅샷이나 Staging Area에 등록되지 않은 파일. 즉 git의 버전 관리 대상이 아닌 상태.
- **Unmodified** - 마지막 커밋(commit) 이후에 아무것도 수정하지 않은 상태.
- **Modified** - 파일의 내용을 변경한 상태.
- **Staged** - 다음 커밋에서 저장하도록 Staging Area에 등록되고 표시된 상태.

## 3. pull
- 저장소 내용 꺼내기
1. 다운로드한다
2. 변경파일을 working directory로 꺼낸다.
3. 기존 파일에 변경내용을 합친다. <- merge

```
$git pull
```

## 4. commit과 snapshot
Commit할 경우 Staged 상태의 파일이 Snapshot에 찍히는 개념으로 이해, 이때 변경되지 않은 파일도 같이 .git에 저장된다고 본다. 또 Delete 상태의 파일 snapshot에 나옴

### 4.1 git log, checkout
```
$git log -> 커밋한 것들 로그 출력
$git log --oneline -> 한줄로 간단하게 출력
$git checkout 커밋ID(해시?) or main -> 해당 커밋버전의 내용으로 파일 자체를 바꿈, 즉 복구가 가능
```

## git config
config 설정에 대한 코드는 다음과 같다.
```
git config --list 등록된
git config user.name <값> 사용자 이름 등록
git config user.email <값> 이메일 등록
```

## 6. commit과 충돌관리 
### 6.1 충돌이 발생하는 경우
```
1. 로컬1 에서 작업 후 커밋하여 푸시함
2. 로컬2 에서 동일한 파일에 대해 작업 후 서버에 푸시하려고 하면 발생
```

### 6.2 충돌을 해결하는 방법
```
1. 서버에서 다시 pull한 후 merge 명령어를 줌
2. 그러면 파일이 병합됨, 상의하여 조정 후 다시 push하면 새 버전으로 업데이트 된다.
```

## <b style="color:red">결론 Git</b>
- 백업하고 서버에 올릴 때
```
$git add 파일이름
$git commit -m "메세지" or git commit 후 vi 편집기 사용
$git push
```  
- 다른 사람 작업을 가져오고 싶을 때
```
가져오고 싶은 작업의 github 주소 확인
$git clone https://github.com/사용자이름/주소
$git pull 
```



# MarkDown(md)
텍스트와 간단한 명령을 통해 컴파일 하여 HTML문서를 작성하고 웹브라우저에 출력할 수 있다. 
**MarkDown은 HTML 문법보다 간결하다**

## 1. 텍스트 파일 종류
- plain text: 아무것도 할 수 없는 텍스트만 존재하는 파일, 텍스트 파일 뷰어 필요
- MarkDown: 콘텐트를 제어하는 간단한 명령어가 존재, 마크다운 뷰어(에디터) 필요
- HTML: 콘텐트를 제어하는 명령어가 존재, 웹브라우저 필요
- 이 외에도 자바, 파이썬 다 텍스트파일..
- 텍스트 파일은 일반적인 메모장으로 불러올 수 있는 파일들은 전부 텍스트 파일이다. 
- 바이너리 파일(binary file)은 전용 편집기로만 편집 가능
  - 데이터(data)
  - 메타데이터(meta data) = markup = tag

### 1.1 텍스트 파일 편집
  - 메모장
  - vi/nano/emacs
  - vscode ...
    - xml, txt, .java, .css, .html 등 텍스트 편집기로 편집 가능

#### 1.2 바이너리 파일 편집
  - photoshop
  - 프리미어
  - 엑셀
  - 워드
  - 파워포인트
    - .jpg, .mp4, .ppt 등 전용 편집기를 사용해야만 편집 가능
