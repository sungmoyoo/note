# 4. 연산자

## 4.5 조건연산자
조건이 참이면 표현식1을 실행하고, 거짓이면 표현식2를 실행
조건연산자는 결과 값이 왼편의 변수타입과 일치해야 한다.
표현식은 반드시 리턴한 결과 값이 존재해야 한다.
```
조건 ? 표현식1 : 표현식2
int age = 20;
String message = age > 18 ? "성년" : "미성년";
=> 성년
```


### 표현식(expression)
작업 수행 후 값을 리턴하는 statement
```
200  (O)
"hello"  (O)
true  (O)
System.out.println("Hi!")  (X)
Math.abs(-200)  (O)
3*2  (O)
if(){--}  (X)
```

## 4.6 증감연산자(++,--)
전위 연산자(prefix operator) => ++변수, --변수  
변수의 메모리 값을 먼저 증감시킨다.  
전위 연산자는 먼저 변수의 값을 -- 하거나 ++ 한 후에 그 자리에 변수의 값을 놓는다.
```
int a = 100;

++a; => a = a+1 => 101 = 100 + 1
++a; => a = a+1 => 102 = 101 + 1
--a; => a = a-1 => 101 = 102 - 1
--a; => a = a-1 => 100 = 101 - 1

System.out.println(++i); 
아래와 같은 식으로 변하여 실행
-> i = i + 1
   System.out.println(5)

int a = 5
int r = ++a;
r => 6
```

- 응용
```
int i = 2;
int result = ++i + ++i * ++i;
위의 문장은 다음 문장들로 변경된다.
i = i + 1;
t1 = i;
i = i + 1;
t2 = i;
i = i + 1;
t3 = i;
r = t1 + t2 * t3;

int result = 3 + 4 * 5;
int result = 3 + 20;
int result = 23;
```


후위 연산자(postfix operator) => 변수++, 변수--  
증감하기 전 값이 연산결과값이 된다.
```
int a = 100;
a++; => a = a+1
a => 101
a--; => a = a-1
a => 100

int a = 100;
int b;
b = a++;

컴파일 시 아래와 같이 변경된다.
1. int temp = a;
2. a = a+1;
3. b = temp;
b => 100

틀린 예
1. b = a;
2. a = a+1 
=> 항상 r-value를 먼저 실행한 후에 =연산을 수행한다
```

- 주의
1. 증감연산자는 리터럴에 적용할 수 없다.
2. 변수에 동시에 적용할 수 없다.
```
int x = 100++; (X)

int y = 100;
++y++; (X)
1) y = y+1
2) 101++ <= 값에 대해 ++연산을 사용할 수 없다. 
(++y)++; (X)
++(y++); (X)
```

## 대입(할당,배정) 연산자
```
int i = 2;

i = i + 20;
i += 20; // += 연산자를 사용하면 위의 코드를 축약할 수 있다.
System.out.println(i);
=> 21

i = 2;
i *= 5;
System.out.println(i);
=> 10
```

### 연산자 우선순위
```
1) ++, -- 
2) *, /, %
3) +, -
4) =
```

# 흐름제어문
조건문: if, if~else, switch
반복문: while, do~while, for

# 1. 조건문
조건의 true/false 여부에 따라 다른 결과를 출력하도록 하는 구문
## 1.1 if 
- 블록을 안묶어도 되지만 웬만하면 묶는다. (Google style guide)
- 블록 없이 한 문장으로도 처리 가능
```
if (조건) 문장;{
  실행내용1
  실행내용2
}
```

## 1.2 if else
- else는 단독적으로 사용할 수 없다.
- if와 else는 한 문장
```
if (조건) 문장;

if (조건){
  실행내용1
}
else{
  실행내용2
}
```

- 다중 if else
```
if (조건) {
  실행내용1
} else if {
  실행내용2
} else if {
  실행내용3
} else {
  실행내용4
}
```

## 1.3 switch
- 단순한 값으로 프로그램을 제어할 경우, switch문이 유용
- 복잡한 조건, 범위로 제어하는 상황이라면, if문이 유용
- 값으로 4바이트를 초과하는 정수 사용 불가, 변수 사용 불가
```
switch (판단값;int정수,문자열,enum상수){
  case 판단값1:
    실행내용1
    break; (실행 종료)
  case 판단값2:
    실행내용2
    break;
  default: (잘못된 판단값 입력 시)
    실행내용3
}
```

# 2. 반복문
조건이 참인 동안 문장을 계속 실행하도록 하는 구문
## 2.1 while
- 블록없이 한 문장으로도 처리 가능
```
while (조건) 문장;

while (조건){
  실행내용;
} 
```

- break와 continue 활용
```
while (조건){
  if (조건)
    (실행내용1)
    continue; -> 다음 문장을 실행하지 않고 조건으로 이동
  if (조건)
    (실행내용2)
    break; -> 자신이 소속된 가장 가까운 반복문을 종료하고 나간다. 
}
```

- 중첩 반복문 탈출
```
라벨명:
  while (조건){
    while(조건){
      (실행내용)
      if (조건)
        break 라벨명; 라벨에 소속된 문장을 나간다. 
    }
  }
```

## 2.2 do~while
- 최소 한 번은 반복하는 반복문
do {
  실행내용1
  실행내용2
  실행내용3
} while (조건);

## 2.3 for
- for문 안에 선언된 변수는 for 문을 나가는 순간 제거, 종료한 뒤라도 변수 값을 사용하고 싶으면 선언을 for문 밖에서 하면 된다.
- 변수 초기화문장에 여러 개의 변수를 선언할 수 있지만 모두 같은 타입이어야 한다. 
```
for (변수 선언 및 초기화; 조건; 증감문) 문장;

for (변수 선언 및 초기화; 조건; 증감문) {
  실행내용1
  실행내용2
}
```

- for문 중첩과 break
```
이 경우 break 소속된 현재 반복문만 멈춘다.
for (변수 선언 및 초기화; 조건; 증감문){
  for (변수 선언 및 초기화; 조건; 증감문){
    실행내용
    break;
  }
}

라벨명:{
  for (변수 선언 및 초기화; 조건; 증감문){
    for (변수 선언 및 초기화; 조건; 증감문){
      실행내용
      if (조건)
        break 라벨명; -> 라벨로 지정한 문장을 나간다.
    }
    실행내용 -> break 후 실행X
  }
  실행내용 -> break 후 실행X
}
실행내용 -> 라벨 밖이라 종료 후 실행됨
```

- for 중첩과 continue
```
for (변수 선언 및 초기화; 조건; 증감문){
    for (변수 선언 및 초기화; 조건; 증감문){
      실행내용
      if (조건)
        continue -> 다음 줄로 가지 않고 변수증가문으로 이동
      실행내용
  }
}
```

- for(;;)와 배열
```
배열선언과 동시에 배열 초기화를 실행할 경우 new String[] 생략 가능
String[] names = {"홍길동", "임꺽정", "유관순", "윤봉길", "안중근"};

for (int i = 0; i < names.length; i++)
  System.out.println(names[i])
-> 배열 값을 인덱스 순서대로 출력
```

- for(:)와 배열  
배열 전체를 반복하거나 컬렉션 객체(java.util.Iterable 구현체) 전체를 반복할 때 사용
```
for (배열에서 꺼낸 값을 저장할 변수 선언 : 배열주소) 문장;

ex)
String[] names = {"홍길동", "임꺽정", "유관순", "윤봉길", "안중근"};
for (String name : names)
  system.out.println(name);
```

# 키보드 입력 다루기
1. read() <- data를 읽을 때 사용하는 도구(메서드)
```
레퍼런스.read()
-> data를 어디서 읽어야 하는지에 대한 정보
=> read가 작업할 때 필요한 정보를 담고 있는 메모리 
=> 인스턴스(instance) = 객체(Object)
```

## 메서드와 레퍼런스
```
System.out.println("Hello")

println("Hello") -> 실제 작업을 수행하는 명령

println() -> 연산자(operator) = method = message
"Hello" -> 피연산자 = argument(정확한 표현) = parameter<변수>

System.out -> 피연산자, JVM 기본출력장치의 정보가 들어있는 메모리의 주소 = 터미널
println("Hello")는 System.out의 (고정)정보를 사용하여 출력할 대상을 결정한다. 
```
