<span style="font-size:133%">

# 상속
## 3. 상속의 실제적인 의미
```
B obj = new B();
``` 
- 앞의 B는 B클래스의 인스턴스와 상속된 인스턴스의 접근 범위를 부여하는 사용자 정의 타입이다. 
- 뒤의 B()는 B의 인스턴스를 생성하는 명령어로 ()을 굳이 붙이는 이유는 기본생성자를 전달하라는 의미이다. 

## 4. 클래스 로딩과 인스턴스 생성과정
``` 
B는 A를 상속받는다 
B obj = new B(); 
``` 
- 객체 생성 시 생성자와 스태틱 블록, 변수초기화문장이 자동 삽입되듯이, 상속관계에 있는 클래스의 경우 수퍼클래스가 로딩되어 있지 않다면 super() 문장이 삽입되어 수퍼클래스를 먼저 로딩한 후 차례로 리턴하며 실행된다.

## 5. 다중 상속
- 한 수퍼클래스에 여러 서브클래스들은 존재할 수 있지만, 한 서브클래스가 여러 수퍼클래스를 가질 수 없다.
- 그 이유는 두 개의 수퍼클래스에 같은 이름의 메서드가 있다고 가정하면 메서드 호출 시 컴파일러가 어떤 메서드를 호출해야 하는지 알 수 없기 때문이다. 

## 6. 전문화 vs 일반화
- 수퍼클래스에 새 특징이나 기능을 추가하여 특별한 서브클래스를 만드는 상속의 종류를 전문화(Specialization)라고 한다.
- 여러 클래스에 공통으로 들어가는 기능이나 필드가 있을 때 유지보수가 쉽도록 별도의 클래스로 추출하는 것을 일반화라고 한다.

## 7. 추상클래스
- 여러 서브클래스의 공통 기능을 가진 수퍼 클래스는 직접 인스턴스를 만들어 사용하기 위해서 정의한 클래스가 아니다.
- 따라서 해당 클래스를 직접 사용하지 못하게 막고 서브클래스를 만들어 사용하도록 제한하는 것이 추상클래스이다.
```
abstract class 클래스명{...}
```

## 8. 추상메서드 
- 서브클래스에게 공통 기능을 상속해주는 목적으로 만든 메서드이다.
- 어차피 서브클래스에서 재정의할 메서드 또는 서브클래스에서 구현을 강제하려고 한다면 기능을 서브클래스에서만 구현한다.
- 추상메서드를 가진 클래스는 추상클래스여야만 한다. 일반메서드는 인스턴스를 생성하여 메서드를 호출하기 때문이다.


# 다형성
어떤 객체의 속성이나 기능이 상황에 따라 여러 다른 형태 또는 타입으로 변할 수 있는 성질이다. 

# 1. 다형적 변수
코드예제-com.eomcs.oop.ex06.a 
- 레퍼런스는 같은 타입의 객체를 가리킬 수 있을 뿐만 아니라 그 클래스의 서브클래스 객체까지 가리킬 수 있다. 
- 상위 클래스의 레퍼런스로 하위 클래스의 인스턴스를 가리킬 수 있다.
- 반대로 하위 클래스의 레퍼런스로 상위 클래스의 인스턴스를 가리킬 수 없다.
- 물론 다른 클래스의 인스턴스는 가리킬 수 없다. 
- 상위 클래스의 레퍼런스로 하위 클래스의 인스턴스를 가리킬 땐 타입 범위를 벗어나서 사용할 수 없다. 
- 비록 레퍼런스가 Bike 인스턴스를 가리킨다 하더라도 형식상으로는 Vehicle의 레퍼런스 이기 때문에 접근할 수 있는 범위는 Vehicle에 정의된 또는 상위클래스에 정의된 필드와 메서드만 가능하다. 
```  
vehicle.engine = true; // 컴파일 에러
```

# 2. 오버로딩(Overloading)
코드예제-com.eomcs.oop.ex06.b 
: 파라미터의 형식(타입과 개수)은 다르지만 같은 기능을 수행하는 메서드에 대해 같은 이름을 부여함으로써 프로그래밍의 일관성을 제공하기 위한 문법이다.  

- 같은 이름의 메서드를 중복해서 만들 수 없다면 같은 작업을 수행하는 메서드라도 유사하지만 다른 이름으로 만들어야 한다.
=> 이는 일관성이 떨어지고 

- 자바에서는 타입이나 파라미터가 다르더라도 같은 일을 하는 메서드에 대해서 같은 메서드명을 갖게 할 수 있다.
- 아규먼트의 타입이나 개수에 따라 호출하는 메서드가 결정된다.
- 예시로 println(), Integer.valueOf()도 오버로딩을 사용한 메서드들이다.

# 3. 오버라이딩(Overriding)
- 상속받은 메서드를 서브클래스의 역할에 맞게 재정의하는 문법
- 사용법
  - 상속받은 메서드와 똑같은 시그니처로 메서드를 정의한다.
  - 오버라이딩 메서드는 원래의 메서드보다 접근범위가 같거나 커야 한다. 원래의 메서드보다 접근범위가 줄어들면 안된다.

### 3.1 필드 오버라이딩
- 메서드 오버라이딩과 달리 수퍼클래스의 필드를 감춰버린다. 즉 오버라이딩 되면 메서드가 소속된 클래스의 필드부터 찾기 때문에 수퍼클래스나 서브클래스 둘 중 하나의 변수 타입을 사용할 수 없다. 
- 따라서 웬만하면 사용하지 않는다. 

## 3.2 오버라이딩 실수 방지
- 자바 개발자들이 오버라이딩한다는 것을 실수로 파라미터의 형태를 달리해서 오버로딩하는 경우가 많다.
- 이에 대한 해결방법으로 @Override 애노테이션을 사용해서 컴파일러에게 검사를 받을 수 있다.

## 3.3 오버라이딩 접근 범위
- 오버라이딩 메서드의 접근 범위 유지/확대는 가능하다 원래 접근범위보다 좁힐 수는 없다.

### 상속과 super & this reference 
this: 메서드 호출 시 'this 변수에 실제 저장된 인스턴스의 클래스'부터 찾아 올라간다.
super: 메서드 호출 시 '메서드가 소속된 클래스'의 수퍼클래스부터 찾아올라간다.

</span>