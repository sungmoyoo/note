<span style="font-size:133%">

## 3.4 Overriding 메서드의 리턴 타입
오버라이딩 메서드의 리턴 타입은 서브 클래스도 가능하다
```
static class SedanFactory extends CarFactory {
  Car create() {
    return new Sedan();
  }
}
```
## 3.5 오버라이딩 컴파일과 실행의 차이
다형적 변수를 사용법에 따라 슈퍼클래스 레퍼런스로 서브클래스 인스턴스를 가리켰을 때
- 컴파일 시:  
  자바 문법에 따라 작성되었는지 컴파일러가 확인한다. 문법상 컴파일러는 통과될 수 있지만 실제 저장된 인스턴스가 맞지 않으면 실행 시 오류가 발생한다. 

- 실행 시:  
  오버라이딩 메서드 호출 규칙에 따라, 실제 인스턴스가 있는 상속된 서브클래스부터 메소드를 찾아 올라간다.

## 3.6 final
- 클래스:  
클래스에 final을 붙이면 서브클래스를 만들 수 없다.
- 메서드:
메서드에 final을 붙이면 오버라이딩 할 수 없다. 
- 필드:
필드에 final을 붙이면 상수 필드가 된다. 스태틱에만 붙인다. 한번 설정한 후 값을 변경할 수 없다.  
생성자, 변수초기화문장, 인스턴스초기화블록에서 초기화할 수 있다.
- 로컬변수:  
로컬변수에 final을 붙이면 상수가 된다. 
- 파라미터:
파라미터에 final을 붙이면 매서드 안에서 파라미터 값을 임의로 변경하지 못하게 막는다. 


# 추상 클래스
## 1.1 추상클래스와 인스턴스
- 추상 메서드가 있든 없든 추상클래스를 만들 수 있다.
- 서브 클래스에게 공통 필드나 메서드를 상속해주는 것이 목적이다.
- 직접 사용하지 않는다.
- 여러 클래스를 같은 타입으로 묶기 위함이다.
- 상속에서 generalization을 통해 수퍼클래스를 정의 하는 경우에 그 수퍼클래스를 주로 추상클래스로 만든다.

## 1.2 추상클래스와 추상메서드
- 메서드 선언부에 abstact를 붙인다.
- 메서드 바디가 없다.
- 추상클래스나 인터페이스에서만 선언할 수 있다.
  
추상 메서드의 용도
- 서브클래스마다 구현이 다를 수 있는 경우에 사용한다.
- 서브클래스가 반드시 구현해야 하는 메서드가 있다면 추상메서드로 선언 
- 추상메서드를 상속받은 서브클래스는 반드시 추상메서드를 구현해야 한다.
- concrete 클래스와 메서드는 일반 클래스/메서드로서 실제 인스턴스를 생성할 수 있도록 구현하는 클래스/메서드이다.

## 1.3 추상클래스 레퍼런스와 메서드 호출
- 추상 메서드는 구현하지 않은 메서드이기 때문에 일반클래스(구현 클래스; concrete class)는 추상 메서드를 가질 수 없다.
- 추상 클래스만이 추상 메서드를 가질 수 있다. 왜 why? 일반 클래스는 인스턴스를 생성할 수 있고 인스턴스로 메서드를 호출하기 때문에 정의되지 않은 메서드를 호출할 때 오류가 발생하므로 추상메서드를 갖지 않도록 하였다.

## 1.4 응용: Template Method 패턴(GoF)
- 추상클래스와 추상메서드를 활용하여 실행흐름(알고리즘)을 슈퍼클래스에서 정의하고, 구체적인 동작의 정의는 서브클래스에게 맡긴다.

- 동작의 흐름은 변경되면 안되기 때문에 템플릿 메서드는 final로 선언하여 오버라이딩을 막는다. (템플릿 메서드 = 추상클래스에서 동작을 제어하는 메서드를 가진 메서드)


super클래스에서 틀만 잡고(Template) 서브클래스에서 정의

# 추상클래스, 추상메서드 적용과정
## 2.1 적용 전
- 두 객체는 정렬 작업을 수행한다.
- 서로 다른 타입을 가지고 있기 때문에 메서드를 따로따로 만들어야 한다.  

## 2.2 타입 통일
- 정렬 객체를 일관성있게 사용하기 위해 같은 타입으로 묶는다.
- sorter라는 클래스에 상속시키고 정렬하는 메서드를 sort()로 같게 한다.
- 하지만 이 방법은 sorter 클래스는 concrete 클래스여서 인스턴스를 생성하여 파라미터로 넘겨줄 수 있다는 문제점이 존재
- sorter는 직접적인 사용을 하지 않고 구현은 서브클래스에서만 하기 때문에 인스턴스를 생성해서 사용해도 아무런 결과가 나타나지 않는다.

## 2.3 수퍼클래스를 추상클래스로 선언
- sorter처러 공통 필드나 기능을 상속해주는 용도로 만든 클래스는 추상클래스를 선언함으로써 인스턴스 생성을 막는다. 왜 why? 사용하지 않으니까.
- 클래스에 abstract를 붙여서 사용
- 그럼에도 아직 문제점이 존재한다. 클래스는 추상클래스인데 메서드가 일반메서드이기에 상속받은 메서드를 오버라이딩하지 않는 실수를 범할 수 있다. 의도하더라도 기능이 정상 작동하지 않는다. sort를 오버라이딩 하지 않았으니 구현한 코드 자체가 실행되지 않기 때문이다.

## 2.4 추상 메서드의 효용성
- 추상메서드를 선언할 경우 상속받은 서브클래스에서 반드시 해당 메서드를 구현해야만 한다.
- 추상메서드를 사용하면 파라미터로 넘어오는 서브클래스가 무엇인지 따질 필요없이 모두 같은 메서드를 호출하면 된다.

### visualgo
알고리즘을 시각적으로 보여주는 사이트

## 2.5 인터페이스 문법 적용
클래스 사용규칙을 정의하는 문법
- 추상 메서드만 있을 경우, 객체 사용 규칙을 정의하는 인터페이스 문법으로 바꿔도 좋다
- 인터페이스 호출 규칙을 정의하는 것이기 때문에, 모든 메서드는 기본이 public이고, abstract이다.
- 선언에 pulbic abstract를 생략해도 된다. 
- 인터페이스의 추상메서드를 구현하는 것도 오버라이딩이라 부른다.

# 캡슐화
인스턴스의 변수에 추상화 목적에 맞는 유효한 값만 넣을 수 있도록 외부 접근을 제한하는 문법이다.

## 1.1 getter 
- private으로 인스턴스에 대한 직접적인 접근을 막는다.
- 외부에서 값을 조회하는 용도로 get필드명()의 getter를 설정해준다.
- 해당 getter는 private 설정된 인스턴스를 그대로 리턴해주는 역할을 하는 메서드이다.

## 1.2 setter
- private으로 인스턴스 값에 접근하여 저장할 수 없으므로 set필드명()의 setter를 사용한다. 
- 저장하기에 유효한 값인지 확인하는 유효성 검사 후 값을 저장해주는 역할을 하는 메서드이다.

### property
- getter/setter를 다른 말로 property라고 한다.
- getter만 있는 경우 read only property
- setter만 있는 경우 write only property
- 둘다 있는 경우 read/write property

### 인스턴스 멤버 접근 제어
private 이외에도 default, protected, public의 modifier들이 존재한다. 각각 다른 접근범위를 가지고 있다.
- private: 같은 클래스 내
- default: 같은 클래스, 같은 패키지
- protected: 같은 클래스, 같은 패키지, 서브클래스
- public: 모두 공개

### 캡슐화 사용 이유
유효성 검사를 하지 않아 무용함이 있다고 하더라고 실무에서는 getter와 setter를 사용한다. 
- 프로그래밍의 일관성
- 추후에 메서드에 기타 코드를 추가할 경우를 대비

</span> 