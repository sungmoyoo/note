<span style="font-size:133%">

# 접근제어
## public
- 모두 공개되어 어디서든 접근 가능하다.

## default
- 접근제한자를 붙이지 않으면 default가 된다. 
- 같은 클래스, 같은 패키지 내에서 접근할 수 있다.

## private
- 같은 클래스 내에서만 접근 가능하다

## protected
- 같은 클래스, 같은 패키지 또는 서브클래스에서 접근할 수 있다.
- 여기서 서브클래스는 수퍼클래스의 형식에 따라 만들어진 서브클래스의 자기 변수를 의미한다. 
```
수퍼클래스 변수
class Exam extends Y {
  com.eomcs.oop.Y exam = new com.eomcs.oop.Y();
  exam.protectedVar = 100; -> (X)
}

자기 변수
class Exam extends Y {
  Exam exam = new Exam(); 
  exam.protectedVar = 100; -> (O)
}
```
### 파라미터 접근
객체를 파라미터로 받은 경우에도 동일한 접근범위를 가진다.

## Factory Method 패턴
- 객체의 생성과정이 복잡할 때 인스턴스를 생성해주는 메서드를 따로 두는 설계 방법
- private으로 생성자를 막고, 값을 리턴해주는 메서드를 static으로 제공
- 리턴하는 객체들이 각각 다르다

## Singleton 패턴
- 인스턴스를 오직 한 개만 생성하고 관리해야 할 때 인스턴스를 생성해주는 메서드를 따로 두는 설계 방법
- private으로 생성자를 막고, 값을 리턴해주는 메서드를 static으로 제공
- 리턴하는 객체가 하나뿐이다.
- getInstance()메서드를 통해 객체 생성 혹은 리턴한다.

# 캡슐화 적용
## 추상화
- 현실의 객체는 물리적으로 존재하지만 데이터는 존재하지 않는다.
- 이러한 현실의 정보를 컴퓨터에서 다루려면 데이터화와 연산자를 통해 변환해야 한다. 
- 이처럼 현실의 객체나 개념을 변환하는 과정을 추상화라고 한다.
```
ex) 추상적인 데이터
학생 객체 
class Student{
  String name;
  int age;
}

주문 개념
class Order{
  String product;
  int number;
}
```

## 캡슐화
- 인스턴스 변수에 클래스 목적에 맞지 않는 데이터가 들어 갈 수 있다면 추상화가 무너진다.
- 이를 방지하기 위해 클래스 목적에 무효한 값이 들어가지 않도록 접근을 제어하는 문법이 캡슐화이다.
- setter/getter 문법을 통해 유효성 검사를 하는 방식이다.
- 잘못된 값을 넣었을 때 무시하거나 강력하게 알릴 수 있다. (throw new RuntimeException; 예외 처리 문법)

=> 추상화 목적에 어긋나는 사용을 방지하고 못하도록 제한하는 문법, 객체생성과정이 복잡한 경우 코드를 감춤으로써 코드의 유지보수성을 높이는 문법

</span>