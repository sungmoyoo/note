# 1. 변수의 종류

## 1.1 스태틱 필드 = static 변수
- 클래스를 로딩할 때 Method 영역에 생성
- 단 한번만 로딩
- JVM이 종료되면 한꺼번에 제거
- 클래스 블록에서 static을 붙여 선언

## 1.2 인스턴스 필드 = non-static 변수
- new 명령어를 실행할 때 Heap 영역에 생성
- 주소값을 잃어버리거나 변수 사용이 끝나면 가비지가 된다.
- Garbage Collector에 의해 인스턴스가 해제될 때 제거된다.

## 1.3 로컬 변수
- 메서드가 호출될 때 JVM Stack 영역에 생성
- 메서드 블록 내에 선언된 변수이며 메서드 호출이 끝나면 제거된다.
- 외부로부터 아규먼트를 전달받는 로컬변수는 파라미터라고 한다. 

### 중첩클래스
클래스 블록 안에 클래스가 있으면 해당 상위 클래스 내에서만 사용할 클래스를 의미한다.

# 2. 인스턴스 필드
- 클래스 변수는 단 한번만 로딩되기 때문에 여러 작업결과를 개별적으로 다루기 어렵다.
- 인스턴스 변수는 new 명령을 호출할 때마다 생성되기 때문에 개별적으로 다룰 수 있다.

# 3. 클래스 필드
- 모든 인스턴스가 공유하는 값을 저장할 때는 클래스 변수를 사용한다.
- 클래스 변수는 클래스 이름으로 접근해야 한다.

## 3.1 클래스 변수의 응용: 상수
- 타입을 지정할 때 숫자를 이용한다면 소스코드 작성 후 시간이 지났을 때 주석이나 개발문서를 읽지 않는 이상 그 숫자의 의미를 기억하기 쉽지 않다.
- 따라서 사용하는 것이 상수(final)이다.

## 3.2 클래스 변수의 응용: 상수 변수 import
- 특정 클래스를 다른 클래스에서도 사용한다면 nested class로 선언하지 않고 패키지 멤버로 분리한다.
- 패키지 멤버의 스태틱 필드를 사용할 때는 import로 그 변수의 소속을 미리 밝힐 수 있다. 소속을 미리 밝혀두면 클래스 이름 없이 스태틱 변수를 바로 사용할 수 있다.

# 4. 인스턴스 메서드와 클래스 메서드
- 클래스 메서드 = static이 붙은 메서드, 클래스 이름으로 호출
- 인스턴스 메서드 = static이 붙지 않은 메서드, 인스턴스 주소가 있어야만 호출할 수 있다. 

### 호출
- 클래스 메서드는 인스턴스 주소를 사용하여 호출할 수 있지만 인스턴스 메서드는 클래스 이름으로 호출할 수 없다.
- 다만! 인스턴스 메서드로 착각할 수 있으니 클래스 메서드는 클래스 이름으로만 호출해야 한다. 
- 인스턴스 메서드를 호출할 때 인스턴스 값이 무효할 때 nullpointException 에러가 발생한다.

# 5. 내장 변수 this
- 클래스 메서드는 인스턴스 주소 없이 호출되기 때문에 인스턴스 주소를 받는 내장 변수가 없다.
- 인스턴스 메서드는 인스턴스 주소가 있어야만 호출되기 때문에 인스턴스 주소를 받은 변수인 this가 내장되어 있다. 
- this변수를 생략해도 자동으로 붙는다.
- 로컬 변수의 이름이 인스턴스 이름과 같을 경우 this를 붙이지 않을 경우 로컬 변수로 인식하기 때문에 이 상황에서는 반드시 붙여야 한다. 

# 6. 생성자
- 클래스 이름과 같은 이름으로 메서드를 만든다.
- 리턴 타입을 선언하지 않는다. 즉 값을 리턴하지 않는다.
- 인스턴스를 만들 때 자동 호출된다.
- 일반 메서드처럼 나중에 따로 호출할 수 없다.
- 만약 개발자가 생성자를 만들지 않으면 컴파일러가 기본 생성자를 자동으로 추가한다.
- 생성된 인스턴스가 제대로 쓰일 수 있도록 유효한 값으로 초기화시키는 일을 한다.

## 6.1 파라미터를 받는 생성자
- 생성자가 한 개라도 있으면 컴파일러는 기본 생성자는 만들어지지 않는다.
- 파라미터를 받는 생성자는 파라미터로 받은 값을 새로 만든 인스턴스 변수에 저장한다. (초기화 역할)

## 6.2 여러 개의 생성자 정의하기
- 생성자가 여러 개 일 때 파라미터에 전달하는 값으로 호출될 생성자를 구분할 수 있다.
- 인스턴스 생성 후에 나중에 따로 생성자를 호출할 수 없다. new명령이 실행될 때 생성자도 같이 호출된다.
- 논리 값을 받는 생성자는 없다!

## 6.3 생성자 - this()
- 생성자에서 다른 생성자를 호출할 때 사용하는 문법
- 단, 생성자의 첫 문장으로 와야 한다. 다른 문장이 오면 에러발생
- 일반 메서드 안에서는 생성자를 호출할 수 없다.
- 여러개의 생성자에 똑같은 코드가 중복되는 경우에 코드를 재사용하기 위해 this()를 쓴다.

### 이클립스 디버깅 워크스페이스
- breakpoint 설정하면 해당 라인에서 실행을 멈춤
- step into, step over, step return으로 실행과정 한라인씩 관찰 가능하다. 

## 6.4 생성자 호출 막기
- 생성자의 접근 범위를 privat으로 설정하면 외부에서 접근할 수 없기 때문에 생성자를 호출할 수 없다. 결국 인스턴스를 생성하지 못하게 만든다. 
```
class X {
  private X() {
  }
}
```

# 7. 변수 자동 초기화
```
class A{
  static int v1;
  int v2;
  static void m(){
    int v3;
  }
}

A.m();
new A();
1. Method Area에 클래스 로딩, 
2. 스태틱 변수 v1 생성 - 0으로 자동 초기화
3. m()이 call되어 frame이 Stack에 생성
4. 이때 v3 로컬변수는 자동초기화 되지 않는다.
5. new명령 실행 후 v2 인스턴스 변수 생성 - 0으로 자동 초기화
```

## 7.1 인스턴스 필드와 스태틱 필드 자동초기화
- 모든 비트가 '전기 없음'으로 설정된다.
- 이처럼 비트를 전기가 없는 상태로 만드는 것을 초기화라고 한다. 

```
byte v1;    -> 0   |     
short v2;   -> 0   |
char v3;    -> 0   | - 정수 메모리의 전기없음은 0으로 표현
int v4;     -> 0   |
long v5;    -> 0   |
float v6;   -> 0.0f       
double v7;  -> 0.0
boolean v8; -> false
String v9;  -> null 레퍼런스를 초기화 시킨 상태는 null로 표현
```

# 8. 초기화 블록(initializer)
## 8.1 스태틱 initializer
```
class A{
  static{   <- 스태틱 초기화 블록
    코드     <- 스태틱 필드를 유효한 값으로 초기화시키는 코드
  }
}
- 순서
1. 클래스 로딩
2. 스태틱 필드 생성
3. 스태틱 초기화 블록 실행
```
- 여러 개의 스태틱 블록이 있으면 컴파일러는 하나의 블록으로 합친다.
- 클래스가 로딩되는 경우
  - 1) 클래스 멤버, 스태틱 필드나 스태틱 메서드를 사용할 때
  - 2) 인스턴스를 생성할 때(new명령)
- 로딩되지 않는 경우
  - 레퍼런스를 선언할 때는 클래스가 로딩되지 않는다.
  - 이미 클래스가 로딩되어 있다면 메모리 절약을 위해 중복로딩을 하지 않는다.

### 강제 클래스 로딩
- 자바에서 제공하는 도구를 사용하여 클래스를 로딩할 때 클래스가 로딩되어 있지 않다면 강제로 로딩할수도 있다.
- import 하는 것과 상관없이 반드시 패키지 이름을 포함해서 클래스 이름을 지정해야 한다.
```
Class.forName("com.eomcs.oop.ex03.Exam0660$A");
```

import 문장에서는 $ 대신 .을 써야 한다.
```
import com.eomcs.oop.ex03.Exam0650.A
```

# 8.2 인스턴스 초기화 블록
인스턴스 initializer
```
class A{
  {         <- 인스턴스 초기화 블록
    코드     <- 생성자에 넣을 코드
  }
  A(){   }
  A(int){   }
  A(int, int){   }
}
- 순서
1. 컴파일
   - 인스턴스 initializer의 코드를 생성자로 옮긴다.
   - 생성자가 여러개일 때, 각각의 생성자에 모두 옮긴다. 
```
- 여러 생성자에 공통으로 들어갈 코드가 있다면 인스턴스 블록에 작성하면 코드 중복을 줄일 수 있다.
- 컴파일 시 초기화블록 안에 있는 코드를 (모든) 생성자에 삽입되고 초기화 블록이 제거된다.

### 필드초기화, 인스턴스 초기화 블록 복사
- 자바 컴파일러는 variable initializer/initializer block이 있으면 선언된 순서대로 모든 생성자의 첫 부분에 복사한다.

### 변수 초기화 문장
variable initializer, 변수 선언과 동시에 초기화 하는 문장
```
public static class A {
  static int a = 100;
}
위 컴파일 시 아래 코드로 변환해준다

public static class A {
  static int a;

  static {
    a = 100;
  }
}
```