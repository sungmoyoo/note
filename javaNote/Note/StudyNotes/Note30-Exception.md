<span style="font-size:133%">

# 예외 처리 문법
- 메서드를 실행하는 중에 예외가 발생했을 때 호출자에게 알려주는 문법
- 메서드를 호출하는 중에 예외를 받았을 때 처리하는 문법

## 예외 처리 문법의 등장배경
- 예외처리 문법이 등장하기 이전 오류 여부를 알리기 위해 리턴 값을 활용하였다.
- 리턴 값을 활용할 경우 리턴 값이 실제 저장된 값인지 유효하지 않은 값이어서 실행오류인지 구분할 수 없는 상황이 발생할 수도 있다.
- 이를 해결하기 위해 나온 문법이 예외 처리 문법이다.


## 예외 상황을 호출자에게 알리는 방법
1. 리턴 값: 정상적으로 실행된 경우와 오류인 경우를 리턴값으로 구분가능할 때.
2. 예외 정보 던지기: 정상적으로 실행된 경우와 오류인 경우를 리턴값으로 구분할 수 없을 때.

## 예외 정보 던지기 - 호출자에게 예외 상황 보고
```
throws 예외정보를 담은 객체
        "java.lang.Throwable" 타입
```

## 예외 정보 받기 - 예외 처리
```
try{
  예외정보를 던질 수 있는 코드 실행
} catch(예외객체 e) {
  예외정보를 받았을 때 실행할 코드
} finally {
  정상적으로 실행되는 예외가 발생하든 무조건 실행되어야 할 코드
}
```

### getMessage()
getMessage()를 통해 메서드에서 던진 예외객체의 메세지를 catch 실행문에서 출력할 수 있다.


## 예외 전달 구조
- 예외를 보고받을 때 처리하지 않으면 상위 호출자에게 예외를 보고한다.
- 예외가 발생하는 코드를 예외처리한 경우 catch의 코드를 실행한다.
- 예외처리하지 않아 JVM에게 보고된 경우 예외 내용을 트레이스/출력 후 프로그램을 종료한다. 

## 예외 객체 타입
- Throwable
  - Error: System예외, JVM 오류 -> 처리 후 종료해야 함(unrecover)  
    - Application 외부에서 발생
    - 예) stack oveflow, VM 오류..

  - Exception: Application 예외(checked 예외) -> 처리 후 계속 실행 가능(recover)
    - Application 내부에서 발생
    - 예) I/O 오류, 인덱스 무효 오류, SQL 오류..

## 예외 처리 주의사항
- Error는 예외 처리를 거의 할 일이 없지만 catch로 잡는 경우에도 적절한 조치를 처리하고 프로그램을 종료해야 한다.
- 예외를 던질 때 Throwable 클래스를 직접 사용하지 말고 하위클래스를 사용해야 한다.
- 여러 개의 예외를 던지는 경우 메서드 선언부에 그대로 나열하라.
- 단, 너무 많으면 공통 수퍼클래스를 던져도 된다.

## 예외를 던지는 메서드 선언부
- Error 계열의 예외를 던질 경우 throws를 생략할 수 있다. 
- Exception 계열의 예외를 던질 경우 메서드 선언부에 throws 예외타입을 반드시 선언해주어야 한다.

## RunTimeException 예외를 던질 경우
- Exception의 서브클래스임에도 불구하고 메서드 선언부에 예외를 던진다고 선언하지 않아도 된다.
- "Unchecked Exception"이라 부른다. 
- 해당 메서드가 예외 던지는지 검사하지 않는다.
- 보통 스텔스 모드(비유!)로 예외를 전달할 때 사용한다.

## checked Exception
- Exception 계열의 예외(RuntimeException 제외)
- 예외를 던질 수 있다고 선언된 메서드를 호출할 때 예외 상황에 대한 처리를 하지 않으면 컴파일 오류가 발생한다. 
```
checked Exception 메서드 호출 시
1. try ~ catch ~ 로 예외 처리
2. 상위 호출자에서 처리할 것이라고 선언
둘 중 하나는 반드시 해야 한다.

왜? -> 컴파일러가 검사(check)하기 때문에
```

## try ~ catch ~
- 코드 실행 중에 발생된 예외를 중간에 가로챈다.
- try 블록에는 예외가 발생할 수 있는 코드를 둔다.
- 예외가 발생하면 그 예외 객체를 파라미터로 받을 수 있는 catch문을 찾아 실행한다
- catch문은 그 예외를 받아서 처리한다.
- 던지는 예외 개수 만큼 catch 블록을 생성한다. 순서를 구분하기 때문에 반드시 지켜야 한다.
- 여러 개의 예외를 받을 때 수퍼클래스 변수로 먼저 받으면 안된다. 서브클래스 객체도 다 받아버리기 때문이다.
- |(or) 연산자를 사용할 수도 있다.
- 가능한 Error계열의 예외를 받지 않아야 한다. 따라서 Throwable 클래스도 사용하지 않는 것이 좋다.

## finally
- 정상적으로 실행하든, 아니면 예외가 발생하여 catch 블록을 실행하든 finally 블록은 무조건 실행한다.
- finally 블록은 try ~ catch ~ 블록을 나가기 전에 반드시 실행한다. 
- try 에서 사용한 자원을 해제시키는 코드를 주로 둔다.
- catch 없이 try ~ finally ~ 블록을 작성할 수도 있다.
```
catch 블록이 없는 try ~ finally ~ 블록을 작성하는 상황:
1. 예외가 발생하면 그 처리는 호출자에게 맡긴다.
2. 그러나 이 메서드를 호출하는 동안 사용한 자원은 이 메서드를 종료하기 전에 해제시킨다.
```

## try-with-resources
- 자원해제시키는 코드를 매번 finally 블록을 만들어 작성하기가 귀찮다면 try-with-resources 라는 문법을 사용하여 자동으로 close()를 처리할 수 있다.
- 단 java.lang.AutoCloseable 구현체에 대해서만 가능하다.
- 여러 객체를 선언할 때 세미콜론을 기준으로 나뉘고 마지막 문장에는 세미콜론을 붙이지 않아도 된다.
```
try (java.lang.AutoCloseable 구현체) {close()가 있는 객체 선언}

try (Scanner keyScan = new Scanner(System.in);
FileReader in = new FileReader("Hello.java");)
```

## 예외클래스 상속
- 예외클래스의 계층도에서 서브클래스의 목적은 기능을 확장하는 것이 아니다.
- 예외 식별을 용이하게 만들기 위함이다.

</span>