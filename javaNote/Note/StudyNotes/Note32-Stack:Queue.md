### 삭제할 수 없는 가비지의 문제(=늦게 삭제되는)
- 만약 LinkedList에서 연속되는 노드를 두개 삭제했다고 가정하면
- 앞의 노드는 가비지가 되지만 뒤 노드는 완전한 가비지가 아니다.
- 앞의 노드가 뒤 노드 객체 주소를 참조하기 때문이다.
- 가비지 컬렉터가 실행하여 앞의 노드가 제거되면 비로소 뒤 노드가 완전한 가비지가 된다.
- 따라서 가비지 컬렉터는 참조하는 객체를 찾아가 레퍼런스 카운트에 따라 가비지 처리작업을 한다.
- 이때 사용되는 것이 '탐색 알고리즘'이다.

# 인터페이스 활용(실습)
## 인터페이스 활용이 필요한 예1
- LinkedList 대신 ArrayList로 교체하려면 사용법이 동일해야 한다.
- 물론 현재 myapp 실습에서 ArrayList 나 LinkedList의 메서드를 동일하게 만들었다.
- 동일하게 만들었다는 것이지 문법적으로 동일하다는 것이 아니다.

**=> 문법적으로 객체 사용규칙을 통일시키는 것이 유지보수에 좋다**

## 인터페이스 활용이 필요한 예2
- ArrayList 대신 LinkedList로 교체하려면 Handler 클래스의 코드를 변경해야 한다.
- 만약 두 클래스가 동일한 규칙에 따라 작성되었다면 Handler 코드를 변경할 필요가 없어진다.

**=> 두 클래스의 사용법을 통일할 필요가 있다.**

## List 인터페이스 정의 + 추상클래스 활용
```
인터페이스 적용
XxxHandler ------> <inteface>
                      List
                       |-- ArrayList
                       |-- LinkedList
```
```
추상클래스 적용
XxxHandler ------> <inteface>
                      List
                       |
                   <abstract>  - size
                  AbstractList - size()
                       |-- ArrayList
                       |-- LinkedList
```

# Stack, Queue
1. Stack 
  - 정의
    - LIFO(Last-In First-Out) 방식의 자료구조로 마지막으로 넣은 데이터를 먼저 꺼낸다. 
  - 활용
    - Bread crumb 기능 구현할 때  
      ex) 웹브라우저에서 방문한 웹페이지 목록
          파일탐색기에서 디렉토리 방문 목록
    - 프로그래밍에서 호출한 메서드 목록
  - 메서드
    - push(): 데이터를 저장한다.
    - pop(): 마지막에 저장한 데이터를 꺼낸다. (삭제)
    - peek(): 마지막에 저장한 데이터를 리턴한다. (조회)
    - empty(): Stack이 비어있는지 확인 후 boolean을 리턴

2. Queue
  - 정의  
    - FIFO(First-In First-Out) 방식의 자료구조로 먼저 넣은 데이터를 먼저 꺼낸다.
  - 활용
    - 예약 기능 구현
  - 메서드
    - offer(item): 데이터를 저장한다.
    - poll(): 맨 처음 값 꺼내기
    - peek(): 맨 처음 값 조회


## 목록에서 데이터를 꺼내는 방식
캡슐화 -> 감추기 -> 객체로 분리 -> 객체화

1. ArrayList, LinkedList(기존 방식) =  get(index)
2. HashSet = toArray()
3. HashMap, Hashtable = get(key)

**자료구조에 따라 데이터를 꺼내는 방식이 다르다**
=> 일관성 있는 코딩이 불가

따라서
- 값 목록을 직접 꺼내지 않고 
- 규칙(Iterator)에 따라 값을 꺼내주는 객체를 만들고
- 그 값을 꺼내주는 객체를 사용하여 꺼낸다.

=> 값을 꺼내는 알고리즘을 객체화하는 것을 GoF의 "Iterator" 디자인 패턴이라고 한다.
=> 자료구조에 상관없이 일관된 방법으로 값을 조회할 수 있다.



