# Java와 Git
## 1. 컴파일러 버전과 클래스 파일
- 컴파일된 바이트코드는 버전을 따른다.
- 상위 JVM은 하위 버전의 컴파일러로 만들어진 바이트코드를 실행할 수 있지만 하위 JVM은 상위 버전의 컴파일러로 만들어진 바이트코드를 실행할 수 없다.
- 따라서 git 서버에 컴파일된 바이트코드(.class)를 올리면 안된다. 

## 2. 버전관리시스템의 관리대상
```
- 소스파일                   -|
- 문서                       |   관리대상
- 설정파일                   -|

- 개발도구 설정파일                   -|  X
- 빌드 결과물(컴파일 결과 파일)         -|      

개발자의 환경에 따라 달라지는 파일은 관리 대상이 아니다.
빌드 결과물도 관리 대상이 아니다.
```
- 관리대상에서 제외시킬 방법은?
### 2.1 .gitignore
- Git으로 관리하지 않을 파일을 지정한다.
- 예를 들면 로그 파일(.log)이나 빌드 도구가 자동으로 생성한 파일 또는 디렉토리 등.
- 패턴을 사용하여 Git이 무시할 파일을 지정한다.
  - 빈 줄이나 `#`으로 시작하는 줄은 주석으로 간주한다.
  - 표준 Glob 패턴을 사용한다.
  - `/`로 시작하면 하위 디렉토리에 적용되지 않는다.
  - 디렉토리는 끝에 `/`을 붙인다.
  - `!`로 시작하는 파일은 무시하지 않는다.
  - `*`는 와일드카드로서 문자열을 대체한다.

# 애플리케이션 개발 및 실행방식 비교: 인터프리트, 컴파일, 하이브리드

## 1. 인터프리트 방식: Node, Python
- 소스파일을 인터프리터를 통해 읽고 문법검사를 한 다음에 해석을 해서 바로 실행
- .js -----> nodejs
- .py -----> python
- .php ----> php 엔진..

### 1.1 Nodejs 설치 및 실행
- 맥에서 node 설치
```
homebrew 설치 - 터미널에 링크 넣기 - 명령어 두개 요구함
brew install node
```

- node 실행
```
1. 소스파일 작성
2. $ node 소스파일명
```


### 1.2 인터프리터 방식의 특징
- 소스파일을 직접 읽어서 실행
- 실행할 때 소스파일 필요
- 인터프리터가 있어야 한다.
- 실행할 때마다 매번 문법검사 -> 컴파일 방식에 비해서 실행이 느리다.
- 코드에 오류가 있더라도 실행하기 전까지 알 수 없다.
- 소스파일이 사용자에게 넘어갈 수 있음

<br>

#### 소스 라이센스의 종류
- GPL 라이센스
- BSD 라이센스
- MIT 라이센스
- Apache 라이센스

## 2. 컴파일 방식: C
- 소스파일을 컴파일러가 개입하여 실행파일로 만듦 
- 실행파일은 기계어로 되어 있기 때문에 바로 os에 전달하여 실행 
- 게임, 응용프로그램 등 컴파일된 실행파일을 받아서 실행하는 개념
- dll과 같은 설정파일과 배치파일, 기계어도 등등 포함

컴파일과 실행 코드
```
$ gcc Hello.c    -> 컴파일
$ ./Hello        -> 실행 ./은 현 파일 지정 의미
```

### 2.1 컴파일 방식의 특징
- 컴파일 과정에서 문법 검사
- 실행할 때 바로 실행, 인터프리터 X, 컴파일러 X
- 기계어이기 때문에 실행속도가 빠름, 인터프리터 방식에 비해
- 소스코드를 노출하지 않는다, 자산으로 보호할 수 있다.

## 3. 하이브리드 방식: Java, C# 
- 바이트코드(p-code)와 같은 가상의 기계어로 변환
- 컴파일 과정에서 문법 검사
- 바이트코드는 기계어가 아니기 때문에 직접 실행 불가
- 따라서 실행하기 위해서는 바이트코드 인터프리터(JVM)을 통해 읽어서 실행한다.

### 3.1 하이브리드 방식의 특징
- 컴파일 방식의 이점을 취한다. 즉, 소스코드 비노출, 자산으로서 보호
- 컴파일 과정에서 문법검사 완료 -> 실행속도 향상
- 가상의 기계어로 번역함으로써 특정 CPU에 비종속, CPU마다 컴파일 할 필요가 없다.
- os에 JVM이 설치되어있으면 실행 가능
- 진짜 기계어를 실행하는 것보다 느림

<b style="color:red">그러나 os에 상관없이 실행할 수 있다는 것이 더 이득이 되기 때문에 이 방식을 선호.</b>

### 3.2 Java vs C#
```
Java: 소스 -> 바이트코드 -> JVM

 C# : 소스 ->   CIL   -> .NET
```

## 4. JIT(Just In Time) 방식
- 실행 시점에 자주 실행하는 코드, 진짜 기계어로 바꿔놓고 그 기계어를 실행하여 실행속도를 높이는 방식
- 이전 방식은 명령을 하나씩 컴파일 함, 개선 이후 자주 실행되는 일부 명령을 실행 시점에 기계어로 바꿔 보관
- 일부는 기존대로, 일부는 그 기계어를 직접실행
- 보관소를 캐시라고 부름
- 캐시에 보관돤 기계어는 실행 완료할 때 제거된다. 영구히 보관되는 것이 아님.

### 4.1 JIT 방식의 특징
- 실행속도 개선, 상대적으로 하이브리드보다 빠름

## 5. AOT(Ahead of time) 컴파일 방식
- JIT 방식은 실행 시점에 컴파일하기 때문에 일시적으로 실행이 느려지는 문제가 있다.
- 이를 해결할 목적으로 만든 방법이 AOT
- 다운로드 -> 설치 -> 설치 과정에서 미리 컴파일

### 5.1 AOT 컴파일 방식 특징
- 실행속도가 빠르다.
- 설치할 때 기계어로 바꾸기 때문에 설치 시간이 길어졌다.

### 5.2 모바일 앱 배포와 컴파일
- cpu마다 기계어가 다르기 때문에 JIT나 AOT처럼 다운로드 후 앱에서 컴파일 하는 방식을 채택하는 것

플레이스토어(안드로이드)
```
다운로드 -> 설치 -> 컴파일 -> 실행
```  
- 다운로드 후 
앱스토어
```
다운로드 -> 컴파일 -> 설치 -> 실행
```
- 다운로드하는 시점에 컴파일해서 주는 방식. 

# 자바 프로젝트 표준 디렉토리 구조
## 1. Maven 빌드 도구의 표준 디렉토리 구조
1. Maven?
  - 빌드(Build) 도구
2. 빌드?
  - 컴파일 - 테스트 - 보고서/문서 생성 - 배포파일 생성 - 배포
  - S/W 제작 전체 과정
3. 빌드 도구?
  - 빌드 작업을 수행하는 도구
  - Build 도구 자체는 컴파일러가 없다. 
  - 존재하는 컴파일을 사용해서 컴파일을 수행하고 존재하는 디버거를 사용해서 디버그를 수행하고 존재하는 문서생성기를 사용해서 문서를 생성하고 존재하는 배포파일 생성기를 사용해서 배포파일 생성하고 존재하는 테스트 도구를 사용해서 테스팅을 수행한다.
  - 빌드 도구는 스크립트 파일에 설정된 정보를 사용하여 빌드 수행 => 빌드 자동화
  <br>  
  <b style="color:red">사람이 빌드과정에 개입할 필요 없이 전체 자동화가 가능한 것이 빌드의 존재 의의</b>

### 1.1 빌드 스크립트 파일
빌드 스크립트 파일 
- 빌드에 사용할 정보: 소스폴더의 경로 배포파일의 이름 등
- 빌드 순서
- 빌드 할때 사용할 도구

## 2. 빌드 도구
- Ant(apache.org): build.xml
- Maven: pom.xml
- Gradle: build.gradle


```
ant ------------------> Maven -----------------> Gradle
       의존라이브러리              빌드스크립트를 작성할때
       기능을 포함                XML 대신 Groovy 언어 사용
          ||                          ||
      자동 다운로드               프로그래밍 언어를 사용함으로써 
                               보다 정밀하게 빌드과정 제어



*라이브러리: 프로젝트에서 사용하는 다른 개발자가 만든 코드(컴파일된 형태)
```
인간의 도서관에는 책이 있지만 S/W 도서관에는 컴파일된 코드(또는 날것의 코드)가 있다.



