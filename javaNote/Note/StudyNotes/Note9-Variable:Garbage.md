## 출력
### ANSI 컬러 활용해봄

# Java 문법
# 1. 변수
- 변수 = 값을 담을 메모리
- 변수선언 = 값을 담을 메모리를 준비시키는 명령문
*메모리준비 = JVM이 관리하는 메모리에서 일부를 데이터를 저장할 용도로 표시
```
만들 메모리 종류    메모리의 이름
 data type       variable
   int            A
```

## 1.1 data type
자바 기본 데이터 타입 = primitive data type
- 정수
  - byte(1byte)   -128~127
  - short(2byte)  -32768~32767
  - int(4byte)    약 -21억~21억
  - long(8byte)   약 -922경~922경
  
- 부동소수점
  - float(4byte)  유효자릿수 7자리
  - double(8byte) 유효자릿수 15자리
  
- 논리
  - boolean(int, byte) 1/0

- 문자
  - char(2byte) 0~65535

## 1.2 JVM과 메모리
1. 프로그램을 실행
2. 프로그램이 사용할 메모리를 os에서 제공
3. RAM에 os가 할당해준 메모리를 사용
4. 프로그램이 종료되면 종료되는 순간 os가 프로그램이 사용하던 메모리를 모두 회수한다.
```
프로그램을 실행 --> 실행중인 프로그램(process) 
```

## 1.3 변수 할당
```
int a;
4byte 정수

char c;
2byte 유니코드

int x,y,z;
각각 4byte 크기의 메모리 준비

byte b;
b = -72
* = 할당 연산자(assignment 연산자)
```

## 1.4 variables initializer(변수 초기화 문장)
변수 선언과 동시에 할당하는 것
```
int a = 100;
    초기화 문장

int x = 20, y, z = 30; 
```

## 1.5 변수명 
1. 일반변수 -> camel 표기법
단어가 여러개인 변수명의 첫단어 제외 각 단어 시작을 대문자로 함
```
firstName
```

2. 상수(constants)
- 변하지 않는 값
모든 알파벳을 대문자로, 단어 사이에 밑줄(underline) 삽입
변수에 값을 단 한번만 저장할 수 있다. 
```
final int PI = 3.14f;
PI = 3.14159f; (X) 
```

### 문자열(Reference Variable)
크기는 JVM에 따라 다르다.
메모리의 주소를 저장한다.(Reference=레퍼런스;참조)
메모리의 주소로 가면 문자열이 존재
문자열을 저장하는 메모리 = 인스턴스
```
String s;
s = "ABC"
```

## 변수 사용
```
int A = 100;
system.out.println(100);
system.out.println(A);
```

# 2. 배열
- 같은 유형의 메모리를 여러개 만드는 문법
- 메모리를 연속해서 준비

```
데이터타입[] 레퍼런스 = new 데이터타입[변수 개수]; #자바방식
데이터타입 레퍼런스[] = new 데이터타입[변수 개수]; #classic방식(C언어)
int[] arr = new int[3];

실제 int배열이 저장될 메모리를 인스턴스라고 함
arr에는 인스턴스의 주소가 저장됨
```

## 2.1 레퍼런스와 인스턴스
```
int[] arr1;
int[] arr2;

arr1 = new int[3];
배열 인스턴스의 메모리는 0으로 자동 초기화된다. 

arr2 = arr1
arr2에 들어가는 값도 arr1의 인스턴스 주소이기 때문에 둘 모두 같은 인스턴스를 가리킨다.
```

## 2.2 배열의 값 저장
```
int arr1 = new int[3];
arr[1] = 271;
```
- arr은 레퍼런스
- [1]은 배열 인스턴스의 특정 변수를 가리키는 번호 = Index(인덱스)
- 인덱스는 0부터 시작
```
arr1[-1] = 100;
arr1[3] = 100;
인덱스 범위를 벗어나면 실행할 때 오류 발생 = Runtime Exception
=> out of index 오류 발생
```

## 2.3 레퍼런스와 인스턴스2
```
int[] A;
int[] B;

A = new int[3];
B = A

A[1] = 100;

System.out.println(B[1])
출력 결과: 100 
```

## 2.4 인스턴스와 가비지(Garbage), 가비지 컬렉터(Garbage Collector)
```
int[] a = new int[3];
a = new int[2];

1번째 줄에서 주어진 인스턴스 주소를 버리고 2번째 줄에서 새 인스턴스를 주소를 받음
그럼 처음에 받았던 인스턴스 주소는 잃어버려 사용하지 못하게 된다. 
그것이 바로 가비지
```

- 가비지 컬렉터 실행
메모리가 부족해지면 JVM os에 메모리를 추가로 요청하기 전에 가비지 컬렉터를 통해 가비지를 메모리에서 제거하여 사용할 메모리를 확보한다.
- 가비지 컬렉터가 해제하기 전까지는 계속 가비지 상태로 존재한다. => 메모리낭비

ex04 Exam510~Exam

